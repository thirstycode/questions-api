{"tutorials": [{"count": 1, "topic": "What is Python?", "answer": "Python is a popular programming language. It was created by Guido van Rossum, and released in 1991.\nIt is used for:\nweb development (server-side),\nsoftware development,\nmathematics,\nsystem scripting."}, {"count": 2, "topic": "What can Python do?", "answer": "Python can be used on a server to create web applications.\nPython can be used alongside software to create workflows.\nPython can connect to database systems. It can also read and modify files.\nPython can be used to handle big data and perform complex mathematics.\nPython can be used for rapid prototyping, or for production-ready software development."}, {"count": 3, "topic": "Why Python?", "answer": "Python works on different platforms (Windows, Mac, Linux, Raspberry Pi, etc).\nPython has a simple syntax similar to the English language.\nPython has syntax that allows developers to write programs with fewer lines than some other programming languages.\nPython runs on an interpreter system, meaning that code can be executed as soon as it is written. This means that prototyping can be very quick.\nPython can be treated in a procedural way, an object-orientated way or a functional way."}, {"count": 4, "topic": "Good to know", "answer": "The most recent major version of Python is Python 3, which we shall be using in this tutorial. However, Python 2, although not being updated with anything other than security updates, is still quite popular.\nIn this tutorial Python will be written in a text editor. It is possible to write Python in an Integrated Development Environment, such as Thonny, Pycharm, Netbeans or Eclipse which are particularly useful when managing larger collections of Python files."}, {"count": 5, "topic": "Python Syntax compared to other programming languages", "answer": "Python was designed for readability, and has some similarities to the English language with influence from mathematics.\nPython uses new lines to complete a command, as opposed to other programming languages which often use semicolons or parentheses.\nPython relies on indentation, using whitespace, to define scope; such as the scope of loops, functions and classes. Other programming languages often use curly-brackets for this purpose."}, {"count": 6, "topic": "Python Install", "answer": "Many PCs and Macs will have python already installed.\nTo check if you have python installed on a Windows PC, search in the start bar for Python or run the following on the Command Line (cmd.exe):\nC:\\Users\\Your Name>python --version\nTo check if you have python installed on a Linux or Mac, then on linux open the command line or on Mac open the Terminal and type:\npython --version\nIf you find that you do not have python installed on your computer, then you can download it for free from the following website:\u00a0\nDownload the\u00a0.\nRun the installer file and follow the steps to install Python\nDuring the install process, check\u00a0Add Python to environment variables.\u00a0This will add Python to environment variables and you are able to run Python from any part of the computer.\nAlso, you can choose the path where Python is installed.\n\nOnce you finish the installation process, you can run Python."}, {"count": 7, "topic": "1. Run Python in Immediate mode", "answer": "Once Python is installed, typing\u00a0python\u00a0in the command line will invoke the interpreter in immediate mode. We can directly type in Python code and press enter to get the output.\nTry typing in\u00a01 + 1\u00a0and press enter. We get\u00a02\u00a0as the output. This prompt can be used as a calculator. To exit this mode type\u00a0quit()\u00a0and press enter."}, {"count": 8, "topic": "2. Run Python in the Integrated Development Environment (IDE)", "answer": "We can use any text editing software to write a Python script file.\nWe just need to save it with the\u00a0.py\u00a0extension. But using an IDE can make our life a lot easier. IDE is a piece of software that provides useful features like code hinting, syntax highlighting and checking, file explorers etc. to the programmer for application development.\nBy the way, when you install Python, an IDE named\u00a0IDLE\u00a0is also installed.\u00a0You can use it to run Python on your computer. It's a decent IDE for beginners.\nWhen you open IDLE, an interactive Python Shell is opened.\n\nNow you can create a new file and save it with\u00a0.py\u00a0extension.\u00a0For example,\u00a0hello.py\nWrite Python code in the file, save it. To run the file go to\u00a0Run\u00a0>\u00a0Run Module\u00a0or simply click\u00a0F5."}, {"count": 9, "topic": "Your first Python Program", "answer": "Now that we have Python up and running, we can write our first Python program.\nLet's create a very simple program called\u00a0\"Hello World!\".\u00a0 A \"Hello, World!\" is a simple program that outputs\u00a0Hello, World!\u00a0on the screen. Since it's a very simple program, it's often used to introduce a new programming language to a newbie.\nType the following code in any text editor or an IDE and save it as\u00a0helloWorld.py\nprint(\"Hello world!\")\nThen, run the file. You will get the following output.\nHello world!\nCongratulations! You just wrote your first program in Python.\nAs we can see, it was pretty easy. This is the beauty of Python programming language.\nPython Keywords and Identifiers\nIn this tutorial, you will learn about keywords (reserved words in Python) and identifiers (names given to variables, functions, etc.)."}, {"count": 10, "topic": "Python Keywords", "answer": "Keywords are the reserved words in Python.\nWe cannot use a keyword as a\u00a0,\u00a0\u00a0name or any other identifier. They are used to define the syntax and structure of the Python language.\nIn Python, keywords are case sensitive.\nThere are 33 keywords in Python 3.7. This number can vary slightly in the\u00a0course of time.\nAll the keywords except\u00a0True,\u00a0False\u00a0and\u00a0None\u00a0are in lowercase and they must be written as it is. The list of all the keywords is given below.\nLooking at all the keywords at once and trying to figure out what they mean might be overwhelming.\nIf you want to have an overview, here is the complete\u00a0\u00a0with examples."}, {"count": 11, "topic": "Python Identifiers", "answer": "An identifier is a name given to entities like class, functions, variables, etc. It helps to differentiate one entity from another."}, {"count": 12, "topic": "Rules for writing identifiers", "answer": "Identifiers can be a combination of letters in lowercase\u00a0(a to z)\u00a0or uppercase\u00a0(A to Z)\u00a0or digits\u00a0(0 to 9)\u00a0or an underscore\u00a0_.\u00a0Names like\u00a0myClass,\u00a0var_1\u00a0and\u00a0print_this_to_screen, all are valid example.\nAn identifier cannot start with a digit.\u00a01variable\u00a0is invalid, but\u00a0variable1\u00a0is perfectly fine.\nKeywords cannot be used as identifiers.\n\n>>> global = 1\n  File \"<interactive input>\", line 1\n    global = 1\n           ^\nSyntaxError: invalid syntax\nWe cannot use special symbols like\u00a0!,\u00a0@,\u00a0#,\u00a0$,\u00a0%\u00a0etc. in our identifier.\n\n>>> a@ = 0\n  File \"<interactive input>\", line 1\n    a@ = 0\n     ^\nSyntaxError: invalid syntax\nIdentifier can be of any length."}, {"count": 13, "topic": "Things to Remember", "answer": "Python is a case-sensitive language. This means,\u00a0Variable\u00a0and\u00a0variable\u00a0are not the same. Always name identifiers that make sense.\nWhile,\u00a0c = 10\u00a0is valid. Writing\u00a0count = 10\u00a0would make more sense and it would be easier to figure out what it does even when you look at your code after a long gap.\nMultiple words can be separated using an underscore,\u00a0this_is_a_long_variable."}, {"count": 14, "topic": "Execute Python Syntax", "answer": "As we learned in the previous page, Python syntax can be executed by writing directly in the Command Line:\n>>> print(\"Hello, World!\")\nHello, World!\nOr by creating a python file on the server, using the .py file extension, and running it in the Command Line:\nC:\\Users\\Your Name>python myfile.py"}, {"count": 15, "topic": "Python Indentation", "answer": "Indentation refers to the spaces at the beginning of a code line.\nWhere in other programming languages the indentation in code is for readability only, the indentation in Python is very important.\nPython uses indentation to indicate a block of code.\nExample\nif\u00a05\u00a0>\u00a02:\n\u00a0\u00a0print(\"Five is greater than two!\")\n\nPython will give you an error if you skip the indentation:\nExample\nSyntax Error:\nif\u00a05\u00a0>\u00a02:\nprint(\"Five is greater than two!\")\n\nThe number of spaces is up to you as a programmer, but it has to be at least one.\nExample\nif\u00a05\u00a0>\u00a02:\n\u00a0print(\"Five is greater than two!\")\u00a0\u00a0\nif\u00a05\u00a0>\u00a02:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Five is greater than two!\")\u00a0\n\nYou have to use the same number of spaces in the same block of code, otherwise Python will give you an error:\nExample\nSyntax Error:\nif\u00a05\u00a0>\u00a02:\n\u00a0print(\"Five is greater than two!\")\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Five is greater than two!\")"}, {"count": 16, "topic": "Python Comments", "answer": "Comments are very important while writing a program. It describes what's going on inside a program so that a person looking at the source code does not have a hard time figuring it out. You might forget the key details of the program you just wrote in a month's time. So taking time to explain these concepts in form of comments is always fruitful.\nIn Python, we use the hash (#) symbol to start writing a comment.\nIt extends up to the newline character. Comments are for programmers for better understanding of a program. Python Interpreter ignores comment.\u00a0\n#This is a comment\n#print out Hello\nprint('Hello')"}, {"count": 17, "topic": "Multi-line comments", "answer": "If we have comments that extend multiple lines, one way of doing it is to use hash (#) in the beginning of each line. For example:\n#This is a long comment\n#and it extends\n#to multiple lines\nAnother way of doing this is to use triple quotes, either\u00a0'''\u00a0or\u00a0\"\"\".\nThese triple quotes are generally used for multi-line strings. But they can be used as multi-line comment as well. Unless they are not docstrings, they do not generate any extra code.\n\"\"\"This is also a\nperfect example of\nmulti-line comments\"\"\""}, {"count": 18, "topic": "Docstring in Python", "answer": "Docstring is short for documentation string.\nIt is a\u00a0\u00a0that occurs as the first statement in a module, function, class, or method definition. We must write what a function/class does in the docstring."}, {"count": 19, "topic": "Creating Variables", "answer": "Variables are containers for storing data values.\nUnlike other programming languages, Python has no command for declaring a variable.\nA variable is created the moment you first assign a value to it.\nExample\nx =\u00a05\ny =\u00a0\"John\"\nprint(x)\nprint(y)\n\nVariables do not need to be declared with any particular type and can even change type after they have been set.\nExample\nx =\u00a04\u00a0# x is of type int\nx =\u00a0\"Sally\"\u00a0# x is now of type str\nprint(x)\n\nString variables can be declared either by using single or double quotes:\nExample\nx =\u00a0\"John\"\n# is the same as\nx =\u00a0'John'"}, {"count": 20, "topic": "Variable Names", "answer": "A variable can have a short name (like x and y) or a more descriptive name (age, carname, total_volume). Rules for Python variables:\nA variable name must start with a letter or the underscore character\nA variable name cannot start with a number\nA variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ )\nVariable names are case-sensitive (age, Age and AGE are three different variables)\nRemember that variable names are case-sensitive"}, {"count": 21, "topic": "Assign Value to Multiple Variables", "answer": "Python allows you to assign values to multiple variables in one line:\nExample\nx, y, z =\u00a0\"Orange\",\u00a0\"Banana\",\u00a0\"Cherry\"\nprint(x)\nprint(y)\nprint(z)\n\nAnd you can assign the\u00a0same\u00a0value to multiple variables in one line:\nExample\nx = y = z =\u00a0\"Orange\"\nprint(x)\nprint(y)\nprint(z)"}, {"count": 22, "topic": "Output Variables", "answer": "The Python\u00a0print\u00a0statement is often used to output variables.\nTo combine both text and a variable, Python uses the\u00a0+\u00a0character:\nExample\nx =\u00a0\"awesome\"\nprint(\"Python is \"\u00a0+ x)\n\nYou can also use the\u00a0+\u00a0character to add a variable to another variable:\nExample\nx =\u00a0\"Python is \"\ny =\u00a0\"awesome\"\nz =\u00a0 x + y\nprint(z)\n\nFor numbers, the\u00a0+\u00a0character works as a mathematical operator:\nExample\nx =\u00a05\ny =\u00a010\nprint(x + y)\n\nIf you try to combine a string and a number, Python will give you an error:\nExample\nx =\u00a05\ny =\u00a0\"John\"\nprint(x + y)"}, {"count": 23, "topic": "Global Variables", "answer": "Variables that are created outside of a function (as in all of the examples above) are known as global variables.\nGlobal variables can be used by everyone, both inside of functions and outside.\nExample\nCreate a variable outside of a function, and use it inside the function\nx =\u00a0\"awesome\"\n\ndef\u00a0myfunc():\n\u00a0\u00a0print(\"Python is \"\u00a0+ x)\n\nmyfunc()\n\nIf you create a variable with the same name inside a function, this variable will be local, and can only be used inside the function. The global variable with the same name will remain as it was, global and with the original value.\nExample\nCreate a variable inside a function, with the same name as the global variable\nx =\u00a0\"awesome\"\n\ndef\u00a0myfunc():\n\u00a0 x =\u00a0\"fantastic\"\n\u00a0\u00a0print(\"Python is \"\u00a0+ x)\n\nmyfunc()\n\nprint(\"Python is \"\u00a0+ x)"}, {"count": 24, "topic": "Python - Basic Operators", "answer": "Operators are the constructs which can manipulate the value of operands.\nConsider the expression 4 + 5 = 9. Here, 4 and 5 are called operands and + is called operator.\nTypes of Operator\nPython language supports the following types of operators.\nArithmetic Operators\nComparison (Relational) Operators\nAssignment Operators\nLogical Operators\nBitwise Operators\nMembership Operators\nIdentity Operators\nLet us have a look on all operators one by one."}, {"count": 25, "topic": "Python Arithmetic Operators", "answer": "Assume variable a holds 10 and variable b holds 20, then \u2212\n[\u00a0\u00a0]"}, {"count": 26, "topic": "Python Comparison Operators", "answer": "These operators compare the values on either sides of them and decide the relation among them. They are also called Relational operators.\nAssume variable a holds 10 and variable b holds 20, then \u2212\n[\u00a0\u00a0]"}, {"count": 27, "topic": "Python Assignment Operators", "answer": "Assume variable a holds 10 and variable b holds 20, then \u2212\n[\u00a0\u00a0]"}, {"count": 28, "topic": "Python Bitwise Operators", "answer": "Bitwise operator works on bits and performs bit by bit operation. Assume if a = 60; and b = 13; Now in binary format they will be as follows \u2212\na = 0011 1100\nb = 0000 1101\n-----------------\na&b = 0000 1100\na|b = 0011 1101\na^b = 0011 0001\n~a\u00a0 = 1100 0011\nThere are following Bitwise operators supported by Python language\n[\u00a0\u00a0]"}, {"count": 29, "topic": "Python Logical Operators", "answer": "There are following logical operators supported by Python language. Assume variable a holds 10 and variable b holds 20 then\n[\u00a0\u00a0]\nUsed to reverse the logical state of its operand."}, {"count": 30, "topic": "Python Membership Operators", "answer": "Python\u2019s membership operators test for membership in a sequence, such as strings, lists, or tuples. There are two membership operators as explained below \u2212\n[\u00a0\u00a0]"}, {"count": 31, "topic": "Python Identity Operators", "answer": "Identity operators compare the memory locations of two objects. There are two Identity operators explained below \u2212\n[\u00a0\u00a0]"}, {"count": 32, "topic": "Python Operators Precedence", "answer": "The following table lists all operators from highest precedence to lowest.\n[\u00a0\u00a0]"}, {"count": 33, "topic": "Python Numbers", "answer": "There are three numeric types in Python:\nint\nfloat\ncomplex\nVariables of numeric types are created when you assign a value to them:\nExample\nx =\u00a01\u00a0\u00a0\u00a0\u00a0# int\ny =\u00a02.8\u00a0\u00a0# float\nz = 1j\u00a0\u00a0\u00a0# complex\n\nTo verify the type of any object in Python, use the\u00a0type()\u00a0function:\nExample\nprint(type(x))\nprint(type(y))\nprint(type(z))"}, {"count": 34, "topic": "Int", "answer": "Int, or integer, is a whole number, positive or negative, without decimals, of unlimited length.\nExample\nIntegers:\nx =\u00a01\ny =\u00a035656222554887711\nz =\u00a0-3255522\n\nprint(type(x))\nprint(type(y))\nprint(type(z))"}, {"count": 35, "topic": "Float", "answer": "Float, or \"floating point number\" is a number, positive or negative, containing one or more decimals.\nExample\nFloats:\nx =\u00a01.10\ny =\u00a01.0\nz = -35.59\n\nprint(type(x))\nprint(type(y))\nprint(type(z))\n\nFloat can also be scientific numbers with an \"e\" to indicate the power of 10.\nExample\nFloats:\nx =\u00a035e3\ny =\u00a012E4\nz = -87.7e100\n\nprint(type(x))\nprint(type(y))\nprint(type(z))"}, {"count": 36, "topic": "Complex", "answer": "Complex numbers are written with a \"j\" as the imaginary part:\nExample\nComplex:\nx =\u00a03+5j\ny = 5j\nz = -5j\n\nprint(type(x))\nprint(type(y))\nprint(type(z))"}, {"count": 37, "topic": "Python\u00a0Casting", "answer": "Specify a Variable Type\nThere may be times when you want to specify a type on to a variable. This can be done with casting. Python is an object-orientated language, and as such it uses classes to define data types, including its primitive types.\nCasting in python is therefore done using constructor functions:\nint()\u00a0- constructs an integer number from an integer literal, a float literal (by rounding down to the previous whole number), or a string literal (providing the string represents a whole number)\nfloat()\u00a0- constructs a float number from an integer literal, a float literal or a string literal (providing the string represents a float or an integer)\nstr()\u00a0- constructs a string from a wide variety of data types, including strings, integer literals and float literals\nExample\nIntegers:\nx =\u00a0int(1)\u00a0\u00a0\u00a0# x will be 1\ny =\u00a0int(2.8)\u00a0# y will be 2\nz =\u00a0int(\"3\")\u00a0# z will be 3\n\n\nExample\nFloats:\nx =\u00a0float(1)\u00a0\u00a0\u00a0\u00a0\u00a0# x will be 1.0\ny =\u00a0float(2.8)\u00a0\u00a0\u00a0# y will be 2.8\nz =\u00a0float(\"3\")\u00a0\u00a0\u00a0# z will be 3.0\nw =\u00a0float(\"4.2\")\u00a0# w will be 4.2\n\n\nExample\nStrings:\nx =\u00a0str(\"s1\")\u00a0# x will be 's1'\ny =\u00a0str(2)\u00a0\u00a0\u00a0\u00a0# y will be '2'\nz =\u00a0str(3.0)\u00a0\u00a0# z will be '3.0'"}, {"count": 38, "topic": "String Literals", "answer": "String literals in python are surrounded by either single quotation marks, or double quotation marks.\n'hello'\u00a0is the same as\u00a0\"hello\".\nYou can display a string literal with the\u00a0print()\u00a0function:\nExample\nprint(\"Hello\")\nprint('Hello')"}, {"count": 39, "topic": "Assign String to a Variable", "answer": "Assigning a string to a variable is done with the variable name followed by an equal sign and the string:\nExample\na =\u00a0\"Hello\"\nprint(a)"}, {"count": 40, "topic": "Multiline Strings", "answer": "You can assign a multiline string to a variable by using three quotes:\nExample\nYou can use three double quotes:\na =\u00a0\"\"\"Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt\nut labore et dolore magna aliqua.\"\"\"\nprint(a)\n\nOr three single quotes:\nExample\na =\u00a0'''Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt\nut labore et dolore magna aliqua.'''\nprint(a)\n\nNote:\u00a0in the result, the line breaks are inserted at the same position as in the code."}, {"count": 41, "topic": "Strings are Arrays", "answer": "Like many other popular programming languages, strings in Python are arrays of bytes representing unicode characters.\nHowever, Python does not have a character data type, a single character is simply a string with a length of 1.\nSquare brackets can be used to access elements of the string.\nExample\nGet the character at position 1 (remember that the first character has the position 0):\na =\u00a0\"Hello, World!\"\nprint(a[1])"}, {"count": 42, "topic": "String Slicing", "answer": "You can return a range of characters by using the slice syntax.\nSpecify the start index and the end index, separated by a colon, to return a part of the string.\nExample\nGet the characters from position 2 to position 5 (not included):\nb =\u00a0\"Hello, World!\"\nprint(b[2:5])"}, {"count": 43, "topic": "Negative Indexing", "answer": "Use negative indexes to start the slice from the end of the string:\nExample\nGet the characters from position 5 to position 1, starting the count from the end of the string:\nb =\u00a0\"Hello, World!\"\nprint(b[-5:-2])"}, {"count": 44, "topic": "String Length", "answer": "To get the length of a string, use the\u00a0len()\u00a0function.\nExample\nThe\u00a0len()\u00a0function returns the length of a string:\na =\u00a0\"Hello, World!\"\nprint(len(a))"}, {"count": 45, "topic": "String Methods", "answer": "Python has a set of built-in methods that you can use on strings.\nExample\nThe\u00a0strip()\u00a0method removes any whitespace from the beginning or the end:\na =\u00a0\" Hello, World! \"\nprint(a.strip())\u00a0# returns \"Hello, World!\"\n\nExample\nThe\u00a0lower()\u00a0method returns the string in lower case:\na =\u00a0\"Hello, World!\"\nprint(a.lower())\n\nExample\nThe\u00a0upper()\u00a0method returns the string in upper case:\na =\u00a0\"Hello, World!\"\nprint(a.upper())\n\nExample\nThe\u00a0replace()\u00a0method replaces a string with another string:\na =\u00a0\"Hello, World!\"\nprint(a.replace(\"H\",\u00a0\"J\"))\n\nExample\nThe\u00a0split()\u00a0method splits the string into substrings if it finds instances of the separator:\na =\u00a0\"Hello, World!\"\nprint(a.split(\",\"))\u00a0# returns ['Hello', ' World!']\n\nLearn more about String Methods with our\u00a0"}, {"count": 46, "topic": "Check String", "answer": "To check if a certain phrase or character is present in a string, we can use the keywords\u00a0in\u00a0or\u00a0not in.\nExample\nCheck if the phrase \"ain\" is present in the following text:\ntxt =\u00a0\"The rain in Spain stays mainly in the plain\"\nx =\u00a0\"ain\"\u00a0in\u00a0txt\nprint(x)\n\nExample\nCheck if the phrase \"ain\" is NOT present in the following text:\ntxt =\u00a0\"The rain in Spain stays mainly in the plain\"\nx =\u00a0\"ain\"\u00a0not\u00a0in\u00a0txt\nprint(x)\u00a0"}, {"count": 47, "topic": "String Concatenation", "answer": "To concatenate, or combine, two strings you can use the + operator.\nExample\nMerge variable\u00a0a\u00a0with variable\u00a0b\u00a0into variable\u00a0c:\na =\u00a0\"Hello\"\nb =\u00a0\"World\"\nc = a + b\nprint(c)\n\nExample\nTo add a space between them, add a\u00a0\" \":\na =\u00a0\"Hello\"\nb =\u00a0\"World\"\nc = a +\u00a0\" \"\u00a0+ b\nprint(c)"}, {"count": 48, "topic": "String Format", "answer": "As we learned in the Python Variables chapter, we cannot combine strings and numbers like this:\nExample\nage =\u00a036\ntxt =\u00a0\"My name is John, I am \"\u00a0+ age\nprint(txt)\n\nBut we can combine strings and numbers by using the\u00a0format()\u00a0method!\nThe\u00a0format()\u00a0method takes the passed arguments, formats them, and places them in the string where the placeholders\u00a0{}\u00a0are:\nExample\nUse the\u00a0format()\u00a0method to insert numbers into strings:\nage =\u00a036\ntxt =\u00a0\"My name is John, and I am {}\"\nprint(txt.format(age))\n\nThe format() method takes unlimited number of arguments, and are placed into the respective placeholders:\nExample\nquantity =\u00a03\nitemno =\u00a0567\nprice =\u00a049.95\nmyorder =\u00a0\"I want {} pieces of item {} for {} dollars.\"\nprint(myorder.format(quantity,\u00a0itemno, price))\n\nYou can use index numbers\u00a0{0}\u00a0to be sure the arguments are placed in the correct placeholders:\nExample\nquantity =\u00a03\nitemno =\u00a0567\nprice =\u00a049.95\nmyorder =\u00a0\"I want to pay {2} dollars for {0} pieces of item {1}.\"\nprint(myorder.format(quantity,\u00a0itemno, price))"}, {"count": 49, "topic": "Python List", "answer": "\u00a0is an ordered sequence of items. It is one of the most used datatype in Python and is very flexible. All the items in a list do not need to be of the same type.\nDeclaring a list is pretty straight forward. Items separated by commas are enclosed within brackets [ ].\n>>> a = [1, 2.2, 'python']\nWe can use the slicing operator [ ] to extract an item or a range of items from a list. Index starts form 0 in Python.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\na = [5,10,15,20,25,30,35,40]\n# a[2] = 15\nprint(\"a[2] = \", a[2])\n# a[0:3] = [5, 10, 15]\nprint(\"a[0:3] = \", a[0:3])\n# a[5:] = [30, 35, 40]\nprint(\"a[5:] = \", a[5:])\n\n\nLists are mutable, meaning, value of elements of a list can be altered.\n>>> a = [1,2,3]\n>>> a[2]=4\n>>> a\n[1, 2, 4]"}, {"count": 50, "topic": "Python Tuple", "answer": "\u00a0is an ordered sequence of items same as list.The only difference is that tuples are immutable. Tuples once created cannot be modified.\nTuples are used to write-protect data and are usually faster than list as it cannot change dynamically.\nIt is defined within parentheses () where items are separated by commas.\n>>> t = (5,'program', 1+3j)\nWe can use the slicing operator [] to extract items but we cannot change its value.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nt = (5,'program', 1+3j)\n# t[1] = 'program'\nprint(\"t[1] = \", t[1])\n# t[0:3] = (5, 'program', (1+3j))\nprint(\"t[0:3] = \", t[0:3])\n# Generates error\n# Tuples are immutable\nt[0] = 10"}, {"count": 51, "topic": "Python\u00a0Sets", "answer": "\nSet\nA set is a collection which is unordered and unindexed. In Python sets are written with curly brackets.\nExample\nCreate a Set:\nthisset = {\"apple\",\u00a0\"banana\",\u00a0\"cherry\"}\nprint(thisset)\n\nNote:\u00a0Sets are unordered, so you cannot be sure in which order the items will appear.\n\nAccess Items\nYou cannot access items in a set by referring to an index, since sets are unordered the items has no index.\nBut you can loop through the set items using a\u00a0for\u00a0loop, or ask if a specified value is present in a set, by using the\u00a0in\u00a0keyword.\nExample\nLoop through the set, and print the values:\nthisset = {\"apple\",\u00a0\"banana\",\u00a0\"cherry\"}\n\nfor\u00a0x\u00a0in\u00a0thisset:\n\u00a0\u00a0print(x)\n\nExample\nCheck if \"banana\" is present in the set:\nthisset = {\"apple\",\u00a0\"banana\",\u00a0\"cherry\"}\n\nprint(\"banana\"\u00a0in\u00a0thisset)\n\n\nChange Items\nOnce a set is created, you cannot change its items, but you can add new items.\n\nAdd Items\nTo add one item to a set use the\u00a0add()\u00a0method.\nTo add more than one item to a set use the\u00a0update()\u00a0method.\nExample\nAdd an item to a set, using the\u00a0add()\u00a0method:\nthisset = {\"apple\",\u00a0\"banana\",\u00a0\"cherry\"}\n\nthisset.add(\"orange\")\n\nprint(thisset)"}, {"count": 52, "topic": "Python Dictionary", "answer": "\u00a0is an unordered collection of key-value pairs.\nIt is generally used when we have a huge amount of data. Dictionaries are optimized for retrieving data. We must know the key to retrieve the value.\nIn Python, dictionaries are defined within braces {} with each item being a pair in the form\u00a0key:value. Key and value can be of any type.\n>>> d = {1:'value','key':2}\n>>> type(d)\n<class 'dict'>\nWe use key to retrieve the respective value. But not the other way around.\n\nExample\nCreate and print a dictionary:\nthisdict = {\n\u00a0\u00a0\"brand\":\u00a0\"Ford\",\n\u00a0\u00a0\"model\":\u00a0\"Mustang\",\n\u00a0\u00a0\"year\":\u00a01964\n}\nprint(thisdict)\n\n\n\nAccessing Items\nYou can access the items of a dictionary by referring to its key name, inside square brackets:\nExample\nGet the value of the \"model\" key:\nx = thisdict[\"model\"]\n\n\nThere is also a method called\u00a0get()\u00a0that will give you the same result:\nExample\nGet the value of the \"model\" key:\nx = thisdict.get(\"model\")\n\n\n\n\nChange Values\nYou can change the value of a specific item by referring to its key name:\nExample\nChange the \"year\" to 2018:\nthisdict = {\n\u00a0\u00a0\"brand\":\u00a0\"Ford\",\n\u00a0\u00a0\"model\":\u00a0\"Mustang\",\n\u00a0\u00a0\"year\":\u00a01964\n}\nthisdict[\"year\"] =\u00a02018\n\n\n\nCheck if Key Exists\nTo determine if a specified key is present in a dictionary use the\u00a0in\u00a0keyword:\nExample\nCheck if \"model\" is present in the dictionary:\nthisdict = {\n\u00a0\u00a0\"brand\":\u00a0\"Ford\",\n\u00a0\u00a0\"model\":\u00a0\"Mustang\",\n\u00a0\u00a0\"year\":\u00a01964\n}\nif\u00a0\"model\"\u00a0in\u00a0thisdict:\n\u00a0\u00a0print(\"Yes, 'model' is one of the keys in the thisdict dictionary\")\n\n\nDictionary Length\nTo determine how many items (key-value pairs) a dictionary has, use the\u00a0len()\u00a0method.\nExample\nPrint the number of items in the dictionary:\nprint(len(thisdict))\n\n\nAdding Items\nAdding an item to the dictionary is done by using a new index key and assigning a value to it:\nExample\nthisdict = {\n\u00a0\u00a0\"brand\":\u00a0\"Ford\",\n\u00a0\u00a0\"model\":\u00a0\"Mustang\",\n\u00a0\u00a0\"year\":\u00a01964\n}\nthisdict[\"color\"] =\u00a0\"red\"\nprint(thisdict)\n\n\n\nRemoving Items\nThere are several methods to remove items from a dictionary:\nExample\nThe\u00a0pop()\u00a0method removes the item with the specified key name:\nthisdict = {\n\u00a0\u00a0\"brand\":\u00a0\"Ford\",\n\u00a0\u00a0\"model\":\u00a0\"Mustang\",\n\u00a0\u00a0\"year\":\u00a01964\n}\nthisdict.pop(\"model\")\nprint(thisdict)"}, {"count": 53, "topic": "Python - Decision Making", "answer": "Decision making is anticipation of conditions occurring while execution of the program and specifying actions taken according to the conditions.\nDecision structures evaluate multiple expressions which produce TRUE or FALSE as outcome. You need to determine which action to take and which statements to execute if outcome is TRUE or FALSE otherwise.\nFollowing is the general form of a typical decision making structure found in most of the programming languages \u2212\n\nPython programming language assumes any\u00a0non-zero\u00a0and\u00a0non-null\u00a0values as TRUE, and if it is either\u00a0zero\u00a0or\u00a0null, then it is assumed as FALSE value."}, {"count": 54, "topic": "Python Conditions and If statements", "answer": "Python supports the usual logical conditions from mathematics:\nEquals:\u00a0a == b\nNot Equals:\u00a0a != b\nLess than:\u00a0a < b\nLess than or equal to:\u00a0a <= b\nGreater than:\u00a0a > b\nGreater than or equal to:\u00a0a >= b\nThese conditions can be used in several ways, most commonly in \"if statements\" and loops.\nAn \"if statement\" is written by using the\u00a0if\u00a0keyword.\nExample\nIf statement:\na =\u00a033\nb =\u00a0200\nif\u00a0b > a:\n\u00a0\u00a0print(\"b is greater than a\")\n\nIn this example we use two variables,\u00a0a\u00a0and\u00a0b, which are used as part of the if statement to test whether\u00a0b\u00a0is greater than\u00a0a. As\u00a0a\u00a0is\u00a033, and\u00a0b\u00a0is\u00a0200, we know that 200 is greater than 33, and so we print to screen that \"b is greater than a\"."}, {"count": 55, "topic": "Indentation", "answer": "Python relies on indentation (whitespace at the beginning of a line) to define scope in the code. Other programming languages often use curly-brackets for this purpose.\nExample\nIf statement, without indentation (will raise an error):\na =\u00a033\nb =\u00a0200\nif\u00a0b > a:\nprint(\"b is greater than a\")\u00a0# you will get an error"}, {"count": 56, "topic": "Elif", "answer": "The\u00a0elif\u00a0keyword is pythons way of saying \"if the previous conditions were not true, then try this condition\".\nExample\na =\u00a033\nb =\u00a033\nif\u00a0b > a:\n\u00a0\u00a0print(\"b is greater than a\")\nelif\u00a0a == b:\n\u00a0\u00a0print(\"a and b are equal\")\n\n\nIn this example\u00a0a\u00a0is equal to\u00a0b, so the first condition is not true, but the\u00a0elif\u00a0condition is true, so we print to screen that \"a and b are equal\"."}, {"count": 57, "topic": "Else", "answer": "The\u00a0else\u00a0keyword catches anything which isn't caught by the preceding conditions.\nExample\na =\u00a0200\nb =\u00a033\nif\u00a0b > a:\n\u00a0\u00a0print(\"b is greater than a\")\nelif\u00a0a == b:\n\u00a0\u00a0print(\"a and b are equal\")\nelse:\n\u00a0\u00a0print(\"a is greater than b\")\n\n\nIn this example\u00a0a\u00a0is greater than\u00a0b, so the first condition is not true, also the\u00a0elif\u00a0condition is not true, so we go to the\u00a0elsecondition and print to screen that \"a is greater than b\".\nYou can also have an\u00a0else\u00a0without the\u00a0elif:\nExample\na =\u00a0200\nb =\u00a033\nif\u00a0b > a:\n\u00a0\u00a0print(\"b is greater than a\")\nelse:\n\u00a0\u00a0print(\"b is not greater than a\")"}, {"count": 58, "topic": "Python - Loops", "answer": "In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on. There may be a situation when you need to execute a block of code several number of times.\nProgramming languages provide various control structures that allow for more complicated execution paths.\nA loop statement allows us to execute a statement or group of statements multiple times. The following diagram illustrates a loop statement \u2212\n\nPython programming language provides following types of loops to handle looping requirements.\nLoop Control Statements\nLoop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.\nPython supports the following control statements. Click the following links to check their detail.\nLet us go through the loop control statements briefly"}, {"count": 59, "topic": "What is for loop in Python?", "answer": "The for loop in Python is used to iterate over a sequence (,\u00a0,\u00a0) or other iterable objects. Iterating over a sequence is called traversal.\nSyntax of for Loop\nfor val in sequence:\n\tBody of for\nHere,\u00a0val\u00a0is the variable that takes the value of the item inside the sequence on each iteration.\nLoop continues until we reach the last item in the sequence. The body of for loop is separated from the rest of the code using indentation.\nFlowchart of for Loop\n\nExample: Python for Loop\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# Program to find the sum of all numbers stored in a list\n# List of numbers\nnumbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]\n# variable to store the sum\nsum = 0\n# iterate over the list\nfor val in numbers:\n    sum = sum+val\n# Output: The sum is 48\nprint(\"The sum is\", sum)\nRun\n\n\nwhen you run the program, the output will be:\nThe sum is 48"}, {"count": 60, "topic": "The range() function", "answer": "We can generate a sequence of numbers using\u00a0range()\u00a0function.\u00a0range(10)\u00a0will generate numbers from 0 to 9 (10 numbers).\nWe can also define the start, stop and step size as\u00a0range(start,stop,step size). step size defaults to 1 if not provided.\nThis function does not store all the values in memory, it would be inefficient. So it remembers the start, stop, step size and generates the next number on the go.\nTo force this function to output all the items, we can use the function\u00a0list().\nThe following example will clarify this.\n# Output: range(0, 10)\nprint(range(10))\n\n# Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(list(range(10)))\n\n# Output: [2, 3, 4, 5, 6, 7]\nprint(list(range(2, 8)))\n\n# Output: [2, 5, 8, 11, 14, 17]\nprint(list(range(2, 20, 3)))\t\nWe can use the range() function in for loops to iterate through a sequence of numbers. It can be combined with the\u00a0len()\u00a0function to iterate though a sequence using indexing. Here is an example.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n# Program to iterate through a list using indexing\ngenre = ['pop', 'rock', 'jazz']\n# iterate over the list using index\nfor i in range(len(genre)):\n    print(\"I like\", genre[i])\nRun\n\n\nWhen you run the program, the output will be:\nI like pop\nI like rock\n\u200bI like jazz"}, {"count": 61, "topic": "for loop with else", "answer": "A for loop can have an optional else block as well. The\u00a0else\u00a0part is executed if the items in the sequence used in for loop exhausts.\nbreak statement can be used to stop a for loop. In such case, the else part is ignored.\nHence, a for loop's else part runs if no break occurs.\nHere is an example to illustrate this.\n\n\n\n\n1\n2\n3\n4\n5\n6\ndigits = [0, 1, 5]\nfor i in digits:\n    print(i)\nelse:\n    print(\"No items left.\")\nRun\n\n\nWhen you run the program, the output will be:\n0\n1\n5\nNo items left.\nHere, the for loop prints items of the list until the loop exhausts. When the for loop exhausts, it executes the block of code in the\u00a0else\u00a0and prints\nNo items left."}, {"count": 62, "topic": "The while Loop", "answer": "With the\u00a0while\u00a0loop we can execute a set of statements as long as a condition is true.\nExample\nPrint i as long as i is less than 6:\ni =\u00a01\nwhile\u00a0i <\u00a06:\n\u00a0\u00a0print(i)\n\u00a0\u00a0i +=\u00a01\n\n\nNote:\u00a0remember to increment i, or else the loop will continue forever.\nThe\u00a0while\u00a0loop requires relevant variables to be ready, in this example we need to define an indexing variable,\u00a0i, which we set to 1."}, {"count": 63, "topic": "The break Statement", "answer": "With the\u00a0break\u00a0statement we can stop the loop even if the while condition is true:\nExample\nExit the loop when i is 3:\ni =\u00a01\nwhile\u00a0i <\u00a06:\n\u00a0\u00a0print(i)\n\u00a0\u00a0if\u00a0i ==\u00a03:\n\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0i +=\u00a01"}, {"count": 64, "topic": "The continue Statement", "answer": "With the\u00a0continue\u00a0statement we can stop the current iteration, and continue with the next:\nExample\nContinue to the next iteration if i is 3:\ni =\u00a00\nwhile\u00a0i <\u00a06:\n\u00a0\u00a0i +=\u00a01\u00a0\n\u00a0\u00a0if\u00a0i ==\u00a03:\n\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\u00a0print(i)"}, {"count": 65, "topic": "The else Statement", "answer": "With the\u00a0else\u00a0statement we can run a block of code once when the condition no longer is true:\nExample\nContinue to the next iteration if i is 3:\ni =\u00a01\nwhile\u00a0i <\u00a06:\n\u00a0\u00a0print(i)\n\u00a0\u00a0i +=\u00a01\nelse:\n\u00a0\u00a0print(\"i is no longer less than 6\")"}, {"count": 66, "topic": "What is the use of break and continue in Python?", "answer": "In Python, break and continue statements can alter the flow of a normal loop.\nLoops iterate over a block of code until test expression is false, but sometimes we wish to terminate the current iteration or even the whole loop without checking test expression.\nThe\u00a0break and continue statements are used in these cases."}, {"count": 67, "topic": "Python break statement", "answer": "The break statement terminates the loop containing it. Control of the program flows to the statement immediately after the body of the loop.\nIf break statement is inside a nested loop (loop inside another loop), break will terminate the innermost loop."}, {"count": 68, "topic": "Syntax of break", "answer": "break\nhe working of break statement in\u00a0\u00a0and\u00a0\u00a0is shown below.\n\nExample: Python break\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# Use of break statement inside loop\nfor val in \"string\":\n    if val == \"i\":\n        break\n    print(val)\nprint(\"The end\")\nRun\n\n\nOutput\ns\nt\nr\nThe end\nIn this program, we iterate through the\u00a0\"string\"\u00a0sequence. We check if the letter is\u00a0\"i\", upon which we break from the loop. Hence, we see in our output that all the letters up till\u00a0\"i\"\u00a0gets printed. After that, the loop terminates."}, {"count": 69, "topic": "Python continue statement", "answer": "The continue statement is used to skip the rest of the code inside a loop for the current iteration only. Loop does not terminate but continues on with the next iteration.\nSyntax of Continue\ncontinue\n\nExample: Python continue\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# Program to show the use of continue statement inside loops\nfor val in \"string\":\n    if val == \"i\":\n        continue\n    print(val)\nprint(\"The end\")\nRun\n\n\nOutput\ns\nt\nr\nn\ng\nThe end\nThis program is same as the above example except the break statement has been replaced with continue.\nWe continue with the loop, if the string is\u00a0\"i\", not executing the rest of the block. Hence, we see in our output that all the letters except\u00a0\"i\"\u00a0gets printed."}, {"count": 70, "topic": "What is pass statement in Python?", "answer": "In Python programming,\u00a0pass\u00a0is a null statement. The difference between a\u00a0and\u00a0pass\u00a0statement in Python is that, while the interpreter ignores a comment entirely,\u00a0pass\u00a0is not ignored.\nHowever, nothing happens when pass is executed. It results into no operation (NOP).\nSyntax of pass\npass\nWe generally use it as a placeholder.\nSuppose we have a\u00a0or a\u00a0\u00a0that is not implemented yet, but we want to implement it in the future. They cannot have an empty body. The interpreter would complain. So, we use the\u00a0pass\u00a0statement to construct a body that does nothing."}, {"count": 71, "topic": "Python\u00a0Functions", "answer": "\nA function is a block of code which only runs when it is called.\nYou can pass data, known as parameters, into a function.\nA function can return data as a result."}, {"count": 72, "topic": "Creating a Function", "answer": "In Python a function is defined using the\u00a0def\u00a0keyword:\nExample\ndef\u00a0my_function():\n\u00a0\u00a0print(\"Hello from a function\")"}, {"count": 73, "topic": "Calling a Function", "answer": "To call a function, use the function name followed by parenthesis:\nExample\ndef\u00a0my_function():\n\u00a0\u00a0print(\"Hello from a function\")\n\nmy_function()"}, {"count": 74, "topic": "Function Parameters", "answer": "Information can be passed to functions as parameter.\nParameters are specified after the function name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma.\nThe following example has a function with one parameter (fname). When the function is called, we pass along a first name, which is used inside the function to print the full name:\nExample\ndef\u00a0my_function(fname):\n\u00a0\u00a0print(fname +\u00a0\" Refsnes\")\n\nmy_function(\"Emil\")\nmy_function(\"Tobias\")\nmy_function(\"Linus\")"}, {"count": 75, "topic": "Default Parameter Value", "answer": "The following example shows how to use a default parameter value.\nIf we call the function without parameter, it uses the default value:\nExample\ndef\u00a0my_function(country =\u00a0\"Norway\"):\n\u00a0\u00a0print(\"I am from \"\u00a0+\u00a0country)\n\nmy_function(\"Sweden\")\nmy_function(\"India\")\nmy_function()\nmy_function(\"Brazil\")"}, {"count": 76, "topic": "Passing a List as a Parameter", "answer": "You can send any data types of parameter to a function (string, number, list, dictionary etc.), and it will be treated as the same data type inside the function.\nE.g. if you send a List as a parameter, it will still be a List when it reaches the function:\nExample\ndef\u00a0my_function(food):\n\u00a0\u00a0for\u00a0x\u00a0in\u00a0food:\n\u00a0\u00a0\u00a0\u00a0print(x)\n\nfruits = [\"apple\",\u00a0\"banana\",\u00a0\"cherry\"]\n\nmy_function(fruits)"}, {"count": 77, "topic": "Return Values", "answer": "To let a function return a value, use the\u00a0return\u00a0statement:\nExample\ndef\u00a0my_function(x):\n\u00a0\u00a0return\u00a05\u00a0* x\n\nprint(my_function(3))\nprint(my_function(5))\nprint(my_function(9))"}, {"count": 78, "topic": "Keyword Arguments", "answer": "You can also send arguments with the\u00a0key\u00a0=\u00a0value\u00a0syntax.\nThis way the order of the arguments does not matter.\nExample\ndef\u00a0my_function(child3, child2, child1):\n\u00a0\u00a0print(\"The youngest child is \"\u00a0+ child3)\n\nmy_function(child1 =\u00a0\"Emil\", child2 =\u00a0\"Tobias\", child3 =\u00a0\"Linus\")\n\nThe phrase\u00a0Keyword Arguments\u00a0are often shortened to\u00a0kwargs\u00a0in Python documentations."}, {"count": 79, "topic": "Arbitrary Arguments", "answer": "If you do not know how many arguments that will be passed into your function, add a\u00a0*\u00a0before the parameter name in the function definition.\nThis way the function will receive a\u00a0tuple\u00a0of arguments, and can access the items accordingly:\nExample\nIf the number of arguments are unknown, add a\u00a0*\u00a0before the parameter name:\ndef\u00a0my_function(*kids):\n\u00a0\u00a0print(\"The youngest child is \"\u00a0+ kids[2])\n\nmy_function(\"Emil\",\u00a0\"Tobias\",\u00a0\"Linus\")"}, {"count": 80, "topic": "Recursion", "answer": "Python also accepts function recursion, which means a defined function can call itself.\nRecursion is a common mathematical and programming concept. It means that a function calls itself. This has the benefit of meaning that you can loop through data to reach a result.\nThe developer should be very careful with recursion as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly recursion can be a very efficient and mathematically-elegant approach to programming.\nIn this example,\u00a0tri_recursion()\u00a0is a function that we have defined to call itself (\"recurse\"). We use the\u00a0k\u00a0variable as the data, which decrements (-1) every time we recurse. The recursion ends when the condition is not greater than 0 (i.e. when it is 0).\nTo a new developer it can take some time to work out how exactly this works, best way to find out is by testing and modifying it.\nExample\nRecursion Example\ndef tri_recursion(k):\n\u00a0\u00a0if(k>0):\n\u00a0\u00a0\u00a0 result = k+tri_recursion(k-1)\n\u00a0\u00a0\u00a0 print(result)\n\u00a0\u00a0else:\n\u00a0\u00a0\u00a0 result =\u00a00\n\u00a0\u00a0return\u00a0result\n\nprint(\"\\n\\nRecursion Example Results\")\ntri_recursion(6)"}, {"count": 81, "topic": "What are lambda functions in Python?", "answer": "In Python, anonymous function is a\u00a0\u00a0that is defined without a name.\nWhile normal functions are defined using the\u00a0def\u00a0keyword, in Python anonymous functions are defined using the\u00a0lambda\u00a0keyword.\nHence, anonymous functions are also called lambda functions."}, {"count": 82, "topic": "How to use lambda Functions in Python?", "answer": "A lambda function in python\u00a0has the following syntax.\nSyntax of Lambda Function\u00a0in python\nlambda arguments: expression\nLambda functions can have any number of arguments but only one expression. The expression is evaluated and returned. Lambda functions can be used wherever function objects are required.\n\nExample of Lambda Function in python\nHere is an example of lambda function that doubles the input value.\n\n\n\n\n1\n2\n3\n4\n5\n6\n# Program to show the use of lambda functions\ndouble = lambda x: x * 2\n# Output: 10\nprint(double(5))\nRun\n\n\nIn the above program,\u00a0lambda x: x * 2\u00a0is the lambda function. Here\u00a0x\u00a0is the argument and\u00a0x * 2\u00a0is the expression that gets evaluated and returned.\nThis function has no name. It returns a function object which is assigned to the identifier\u00a0double. We can now call it as a normal function. The statement\ndouble = lambda x: x * 2\nis nearly the same as\ndef double(x):\n   return x * 2"}, {"count": 83, "topic": "Use of Lambda Function\u00a0in python", "answer": "We use lambda functions when we require a nameless function for a short period of time.\nIn Python, we generally use it as an argument to a higher-order function (a function that takes in other functions as\u00a0). Lambda functions are used along with built-in functions like\u00a0filter(),\u00a0map()\u00a0etc.\nExample use with filter()\nThe\u00a0filter()\u00a0function in Python takes in a function and a list as arguments.\nThe function is called with all the items in the list and a new list is returned which contains items for which the function evaluats to\u00a0True.\nHere is an example use of\u00a0filter()\u00a0function to filter out only even numbers from a list.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# Program to filter out only the even items from a list\nmy_list = [1, 5, 4, 6, 8, 11, 3, 12]\nnew_list = list(filter(lambda x: (x%2 == 0) , my_list))\n# Output: [4, 6, 8, 12]\nprint(new_list)\nRun"}, {"count": 84, "topic": "Example use with map()", "answer": "The\u00a0map()\u00a0function in Python takes in a function and a list.\nThe function is called with all the items in the list and a new list is returned which contains items returned by that function for each item.\nHere is an example use of\u00a0map()\u00a0function to double all the items in a list.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# Program to double each item in a list using map()\nmy_list = [1, 5, 4, 6, 8, 11, 3, 12]\nnew_list = list(map(lambda x: x * 2 , my_list))\n# Output: [2, 10, 8, 12, 16, 22, 6, 24]\nprint(new_list)"}, {"count": 85, "topic": "What are modules in Python?", "answer": "Modules refer to a file containing Python statements and definitions.\nA file containing Python code, for e.g.:\u00a0example.py, is called a module and its module name would be\u00a0example.\nWe use modules to break down large programs into small manageable and organized files. Furthermore, modules provide reusability of code.\nWe can define our most used functions in a module and import it, instead of copying their definitions into different programs.\nLet us create a module. Type the following and save it as\u00a0example.py.\n# Python Module example\n\ndef add(a, b):\n   \"\"\"This program adds two\n   numbers and return the result\"\"\"\n\n   result = a + b\n   return result\nHere, we have defined a\u00a0\u00a0add()\u00a0inside a module named\u00a0example. The function takes in two numbers and returns their sum."}, {"count": 86, "topic": "How to import modules in Python?", "answer": "We can import the definitions inside a module to another module or the interactive interpreter in Python.\nWe use the\u00a0import\u00a0keyword to do this. To import our previously defined module\u00a0example\u00a0we type the following in the Python prompt.\n>>> import example\nThis does not enter the names of the functions defined in\u00a0example\u00a0directly in the current symbol table. It only enters the module name\u00a0example\u00a0there.\nUsing the module name we can access the function using the dot\u00a0.\u00a0operator. For example:\n>>> example.add(4,5.5)\n9.5\nPython has a ton of standard modules available.\nYou can check out the full list of\u00a0\u00a0and what they are for. These files are in the Lib directory inside the location where you installed Python.\nStandard modules can be imported the same way as we import our user-defined modules.\nThere are various ways to import modules. They are listed as follows."}, {"count": 87, "topic": "Python import statement", "answer": "We can import a module using\u00a0import\u00a0statement and access the definitions inside it using the dot operator as described above. Here is an example.\n\n\n\n\n1\n2\n3\n4\n5\n# import statement example\n# to import standard module math\nimport math\nprint(\"The value of pi is\", math.pi)\nRun\n\n\nWhen you run the program, the output will be:\nThe value of pi is 3.141592653589793"}, {"count": 88, "topic": "Import with renaming", "answer": "We can import a module by renaming it as follows.\n\n\n\n\n1\n2\n3\n4\n# import module by renaming it\nimport math as m\nprint(\"The value of pi is\", m.pi)\nRun\n\n\nWe have renamed the\u00a0math\u00a0module as\u00a0m. This can save us typing time in some cases.\nNote that the name\u00a0math\u00a0is not recognized in our scope. Hence,\u00a0math.pi\u00a0is invalid,\u00a0m.pi\u00a0is the correct implementation."}, {"count": 89, "topic": "Python from...import statement", "answer": "We can import specific names from a module without importing the module as a whole. Here is an example.\n\n\n\n\n1\n2\n3\n4\n# import only pi from math module\nfrom math import pi\nprint(\"The value of pi is\", pi)\nRun\n\n\nWe imported only the attribute pi from the module.\nIn such case we don't use the dot operator. We could have imported multiple attributes as follows.\n>>> from math import pi, e\n>>> pi\n3.141592653589793\n>>> e\n2.718281828459045"}, {"count": 90, "topic": "Import all names", "answer": "We can import all names(definitions) from a module using the following construct.\n\n\n\n\n1\n2\n3\n4\n# import all names from the standard module math\nfrom math import *\nprint(\"The value of pi is\", pi)\nRun\n\n\nWe imported all the definitions from the math module. This makes all names except those beginnig with an underscore, visible in our scope.\nImporting everything with the asterisk (*) symbol is not a good programming practice. This can lead to duplicate definitions for an identifier. It also hampers the readability of our code."}, {"count": 91, "topic": "Python Module Search Path", "answer": "While importing a module, Python looks at several places. Interpreter first looks for a built-in module then (if not found) into a list of directories defined in\u00a0sys.path. The search is in this order.\nThe current directory.\nPYTHONPATH\u00a0(an environment variable with a list of directory).\nThe installation-dependent default directory.\n>>> import sys\n>>> sys.path\n['',\n'C:\\\\Python33\\\\Lib\\\\idlelib',\n'C:\\\\Windows\\\\system32\\\\python33.zip',\n'C:\\\\Python33\\\\DLLs',\n'C:\\\\Python33\\\\lib',\n'C:\\\\Python33',\n'C:\\\\Python33\\\\lib\\\\site-packages']\nWe can add modify this list to add our own path."}, {"count": 92, "topic": "Reloading a module", "answer": "The Python interpreter imports a module only once during a session. This makes things more efficient. Here is an example to show how this works.\nSuppose we have the following code in a module named\u00a0my_module.\n# This module shows the effect of\n#  multiple imports and reload\n\nprint(\"This code got executed\")\nNow we see the effect of multiple imports.\n>>> import my_module\nThis code got executed\n>>> import my_module\n>>> import my_module\nWe can see that our code got executed only once. This goes to say that our module was imported only once.\nNow if our module changed during the course of the program, we would have to reload it.One way to do this is to restart the interpreter. But this does not help much.\nPython provides a neat way of doing this. We can use the\u00a0reload()\u00a0function inside the\u00a0imp module to reload a module. This is how its done.\n>>> import imp\n>>> import my_module\nThis code got executed\n>>> import my_module\n>>> imp.reload(my_module)\nThis code got executed\n<module 'my_module' from '.\\\\my_module.py'>"}, {"count": 93, "topic": "The dir() built-in function", "answer": "We can use the\u00a0dir()\u00a0function to find out names that are defined inside a module.\nFor example, we have defined a function\u00a0add()\u00a0in the module\u00a0example\u00a0that we had in the beginning.\n>>> dir(example)\n['__builtins__',\n'__cached__',\n'__doc__',\n'__file__',\n'__initializing__',\n'__loader__',\n'__name__',\n'__package__',\n'add']\nHere, we can see a sorted list of names (along with\u00a0add). All other names that begin with an underscore are default Python attributes associated with the module (we did not define them ourself).\nFor example, the\u00a0__name__\u00a0attribute contains the name of the module.\n>>> import example\n>>> example.__name__\n'example'\nAll the names defined in our current namespace can be found out using the\u00a0dir()\u00a0function without any arguments.\n>>> a = 1\n>>> b = \"hello\"\n>>> import math\n>>> dir()\n['__builtins__', '__doc__', '__name__', 'a', 'b', 'math', 'pyscripter']"}, {"count": 94, "topic": "What are packages?", "answer": "We don't usually store all of our files in our computer in the same location. We use a well-organized hierarchy of directories for easier access.\nSimilar files are kept in the same directory, for example, we may keep all the songs in the \"music\" directory. Analogous to this, Python has packages for directories and\u00a0\u00a0for files.\nAs our application program grows larger in size with a lot of modules, we place similar modules in one package and different modules in different packages. This makes a project (program) easy to manage and conceptually clear.\nSimilar, as a directory can contain sub-directories and files, a Python package can have sub-packages and modules.\nA directory must contain a file named\u00a0__init__.py\u00a0in order for Python to consider it as a package. This file can be left empty but we generally place the initialization code for that package in this file.\nHere is an example. Suppose we are developing a game, one possible organization of packages and modules could be as shown in the figure below."}, {"count": 95, "topic": "Importing module from a package", "answer": "We can import modules from packages using the dot (.) operator.\nFor example, if want to import the\u00a0start\u00a0module in the above example, it is done as follows.\nimport Game.Level.start\nNow if this module contains a\u00a0\u00a0named\u00a0select_difficulty(), we must use the full name to reference it.\nGame.Level.start.select_difficulty(2)\nIf this construct seems lengthy, we can import the module without the package prefix as follows.\nfrom Game.Level import start\nWe can now call the function simply as follows.\nstart.select_difficulty(2)\nYet another way of importing just the required function (or class or variable) form a module within a package would be as follows.\nfrom Game.Level.start import select_difficulty\nNow we can directly call this function.\nselect_difficulty(2)\nAlthough easier, this method is not recommended. Using the full\u00a0\u00a0avoids confusion and prevents two same identifier names from colliding.\nWhile importing packages, Python looks in the list of directories defined in\u00a0sys.path, similar as for\u00a0."}, {"count": 96, "topic": "Python\u00a0File Open", "answer": "\nFile handling is an important part of any web application.\nPython has several functions for creating, reading, updating, and deleting files."}, {"count": 97, "topic": "File Handling", "answer": "The key function for working with files in Python is the\u00a0open()\u00a0function.\nThe\u00a0open()\u00a0function takes two parameters;\u00a0filename, and\u00a0mode.\nThere are four different methods (modes) for opening a file:\n\"r\"\u00a0- Read - Default value. Opens a file for reading, error if the file does not exist\n\"a\"\u00a0- Append - Opens a file for appending, creates the file if it does not exist\n\"w\"\u00a0- Write - Opens a file for writing, creates the file if it does not exist\n\"x\"\u00a0- Create - Creates the specified file, returns an error if the file exists\nIn addition you can specify if the file should be handled as binary or text mode\n\"t\"\u00a0- Text - Default value. Text mode\n\"b\"\u00a0- Binary - Binary mode (e.g. images)\n\nSyntax\nTo open a file for reading it is enough to specify the name of the file:\nf =\u00a0open(\"demofile.txt\")\nThe code above is the same as:\nf =\u00a0open(\"demofile.txt\",\u00a0\"rt\")\nBecause\u00a0\"r\"\u00a0for read, and\u00a0\"t\"\u00a0for text are the default values, you do not need to specify them.\nNote:\u00a0Make sure the file exists, or else you will get an error."}, {"count": 98, "topic": "Python\u00a0File Open", "answer": "\n\nOpen a File on the Server\nAssume we have the following file, located in the same folder as Python:\ndemofile.txt\nHello! Welcome to demofile.txt\nThis file is for testing purposes.\nGood Luck!\nTo open the file, use the built-in\u00a0open()\u00a0function.\nThe\u00a0open()\u00a0function returns a file object, which has a\u00a0read()\u00a0method for reading the content of the file:\nExample\nf =\u00a0open(\"demofile.txt\",\u00a0\"r\")\nprint(f.read())\n\n\nRead Only Parts of the File\nBy default the\u00a0read()\u00a0method returns the whole text, but you can also specify how many characters you want to return:\nExample\nReturn the 5 first characters of the file:\nf =\u00a0open(\"demofile.txt\",\u00a0\"r\")\nprint(f.read(5))\n\n\n\nRead Lines\nYou can return one line by using the\u00a0readline()\u00a0method:\nExample\nRead one line of the file:\nf =\u00a0open(\"demofile.txt\",\u00a0\"r\")\nprint(f.readline())\n\nBy calling\u00a0readline()\u00a0two times, you can read the two first lines:\nExample\nRead two lines of the file:\nf =\u00a0open(\"demofile.txt\",\u00a0\"r\")\nprint(f.readline())\nprint(f.readline())\n\nBy looping through the lines of the file, you can read the whole file, line by line:\nExample\nLoop through the file line by line:\nf =\u00a0open(\"demofile.txt\",\u00a0\"r\")\nfor\u00a0x\u00a0in\u00a0f:\n\u00a0\u00a0print(x)\n\n\nClose Files\nIt is a good practice to always close the file when you are done with it.\nExample\nClose the file when you are finish with it:\nf =\u00a0open(\"demofile.txt\",\u00a0\"r\")\nprint(f.readline())\nf.close()\n\nNote:\u00a0You should always close your files, in some cases, due to buffering, changes made to a file may not show until you close the file."}, {"count": 99, "topic": "Python\u00a0File Write", "answer": "\n\n\nWrite to an Existing File\nTo write to an existing file, you must add a parameter to the\u00a0open()\u00a0function:\n\"a\"\u00a0- Append - will append to the end of the file\n\"w\"\u00a0- Write - will overwrite any existing content\nExample\nOpen the file \"demofile2.txt\" and append content to the file:\nf =\u00a0open(\"demofile2.txt\",\u00a0\"a\")\nf.write(\"Now the file has more content!\")\nf.close()\n\n#open and read the file after the appending:\nf =\u00a0open(\"demofile2.txt\",\u00a0\"r\")\nprint(f.read())\n\nExample\nOpen the file \"demofile3.txt\" and overwrite the content:\nf =\u00a0open(\"demofile3.txt\",\u00a0\"w\")\nf.write(\"Woops! I have deleted the content!\")\nf.close()\n\n#open and read the file after the appending:\nf =\u00a0open(\"demofile3.txt\",\u00a0\"r\")\nprint(f.read())\n\nNote:\u00a0the \"w\" method will overwrite the entire file."}, {"count": 100, "topic": "Create a New File", "answer": "To create a new file in Python, use the\u00a0open()\u00a0method, with one of the following parameters:\n\"x\"\u00a0- Create - will create a file, returns an error if the file exist\n\"a\"\u00a0- Append - will create a file if the specified file does not exist\n\"w\"\u00a0- Write - will create a file if the specified file does not exist\nExample\nCreate a file called \"myfile.txt\":\nf =\u00a0open(\"myfile.txt\",\u00a0\"x\")\nResult: a new empty file is created!\nExample\nCreate a new file if it does not exist:\nf =\u00a0open(\"myfile.txt\",\u00a0\"w\")"}, {"count": 101, "topic": "Python\u00a0Delete File", "answer": "\n\nDelete a File\nTo delete a file, you must import the OS module, and run its\u00a0os.remove()\u00a0function:\nExample\nRemove the file \"demofile.txt\":\nimport\u00a0os\nos.remove(\"demofile.txt\")\n\nCheck if File exist:\nTo avoid getting an error, you might want to check if the file exists before you try to delete it:\nExample\nCheck if file exists,\u00a0then\u00a0delete it:\nimport\u00a0os\nif\u00a0os.path.exists(\"demofile.txt\"):\n\u00a0 os.remove(\"demofile.txt\")\nelse:\n\u00a0\u00a0print(\"The file does not exist\")\n\nDelete Folder\nTo delete an entire folder, use the\u00a0os.rmdir()\u00a0method:\nExample\nRemove the folder \"myfolder\":\nimport\u00a0os\nos.rmdir(\"myfolder\")\nNote:\u00a0You can only remove\u00a0empty\u00a0folders."}, {"count": 102, "topic": "What is Directory in Python?", "answer": "If there are a large number of\u00a0\u00a0in your Python program, you can arrange your code within different directories to make things more manageable.\nA directory or folder is a collection of files and sub directories. Python has the\u00a0os\u00a0, which provides us with many useful methods to work with directories (and files as well)."}, {"count": 103, "topic": "Get Current Directory", "answer": "We can get the present working directory using the\u00a0getcwd()\u00a0method.\nThis method returns the current working directory in the form of a string. We can also use the\u00a0getcwdb()\u00a0method to get it as bytes object.\n>>> import os\n\n>>> os.getcwd()\n'C:\\\\Program Files\\\\PyScripter'\n\n>>> os.getcwdb()\nb'C:\\\\Program Files\\\\PyScripter'\nThe extra backslash implies escape sequence. The\u00a0print()\u00a0function will render this properly.\n>>> print(os.getcwd())\nC:\\Program Files\\PyScripter"}, {"count": 104, "topic": "Changing Directory", "answer": "We can change the current working directory using the\u00a0chdir()\u00a0method.\nThe new path that we want to change to must be supplied as a string to this method. We can use both forward slash (/) or the backward slash (\\) to separate path elements.\nIt is safer to use escape sequence when using the backward slash.\n>>> os.chdir('C:\\\\Python33')\n\n>>> print(os.getcwd())\nC:\\Python33"}, {"count": 105, "topic": "List Directories and Files", "answer": "All files and sub directories inside a directory can be known using the\u00a0listdir()\u00a0method.\nThis method takes in a path and returns a list of sub directories and files in that path. If no path is specified, it returns from the current working directory.\n>>> print(os.getcwd())\nC:\\Python33\n\n>>> os.listdir()\n['DLLs',\n'Doc',\n'include',\n'Lib',\n'libs',\n'LICENSE.txt',\n'NEWS.txt',\n'python.exe',\n'pythonw.exe',\n'README.txt',\n'Scripts',\n'tcl',\n'Tools']\n\n>>> os.listdir('G:\\\\')\n['$RECYCLE.BIN',\n'Movies',\n'Music',\n'Photos',\n'Series',\n'System Volume Information']"}, {"count": 106, "topic": "Making a New Directory", "answer": "We can make a new directory using the\u00a0mkdir()\u00a0method.\nThis method takes in the path of the new directory. If the full path is not specified, the new directory is created in the current working directory.\n>>> os.mkdir('test')\n\n>>> os.listdir()\n['test']"}, {"count": 107, "topic": "Renaming a Directory or a File", "answer": "The\u00a0rename()\u00a0method can rename a directory or a file.\nThe first argument is the old name and the new name must be supplies as the second argument.\n>>> os.listdir()\n['test']\n\n>>> os.rename('test','new_one')\n\n>>> os.listdir()\n['new_one']"}, {"count": 108, "topic": "Removing Directory or File", "answer": "A file can be removed (deleted) using the\u00a0remove()\u00a0method.\nSimilarly, the\u00a0rmdir()\u00a0method removes an empty directory.\n>>> os.listdir()\n['new_one', 'old.txt']\n\n>>> os.remove('old.txt')\n>>> os.listdir()\n['new_one']\n\n>>> os.rmdir('new_one')\n>>> os.listdir()\n[]\nHowever, note that\u00a0rmdir()\u00a0method can only remove empty directories.\nIn order to remove a non-empty directory we can use the\u00a0rmtree()\u00a0method inside the\u00a0shutil\u00a0module.\n>>> os.listdir()\n['test']\n\n>>> os.rmdir('test')\nTraceback (most recent call last):\n...\nOSError: [WinError 145] The directory is not empty: 'test'\n\n>>> import shutil\n\n>>> shutil.rmtree('test')\n>>> os.listdir()\n[]"}, {"count": 109, "topic": "Python Errors and Built-in Exceptions", "answer": "Python (interpreter) raises exceptions when it encounter errors. For example: divided by zero. In this article, you will learn about different exceptions that are built-in in Python.\nWhen writing a program, we, more often than not, will encounter errors.\nError caused by not following the proper structure (syntax) of the language is called syntax error or parsing error.\n>>> if a < 3\n  File \"<interactive input>\", line 1\n    if a < 3\n           ^\nSyntaxError: invalid syntax\nWe can notice here that a colon is missing in the\u00a0if\u00a0statement.\nErrors can also occur at runtime and these are called exceptions. They occur, for example, when a file we try to open does not exist (FileNotFoundError), dividing a number by zero (ZeroDivisionError), module we try to import is not found (ImportError) etc.\nWhenever these type of runtime error occur, Python creates an exception object. If not handled properly, it prints a traceback to that error along with some details about why that error occurred.\n>>> 1 / 0\nTraceback (most recent call last):\n File \"<string>\", line 301, in runcode\n File \"<interactive input>\", line 1, in <module>\nZeroDivisionError: division by zero\n\n>>> open(\"imaginary.txt\")\nTraceback (most recent call last):\n File \"<string>\", line 301, in runcode\n File \"<interactive input>\", line 1, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: 'imaginary.txt'"}, {"count": 110, "topic": "Python Built-in Exceptions", "answer": "Illegal operations can raise exceptions. There are plenty of built-in exceptions in Python that are raised when corresponding errors occur. We can view all the built-in exceptions using the\u00a0local()\u00a0built-in functions as follows.\n>>> locals()['__builtins__']\nThis will return us a dictionary of built-in exceptions, functions and attributes.\nSome of the common built-in exceptions in Python programming along with the error that cause then are tabulated below.\nWe can also define our own exception in Python (if required). Visit this page to learn more about\u00a0.\u00a0\nWe can handle these built-in and user-defined\u00a0.\u00a0"}, {"count": 111, "topic": "What are exceptions in Python?", "answer": "Python has many\u00a0\u00a0which forces your program to output an error when something in it goes wrong.\nWhen these exceptions occur, it causes the current process to stop and passes it to the calling process until it is handled. If not handled, our program will crash.\nFor example, if\u00a0\u00a0A\u00a0calls function\u00a0B\u00a0which in turn calls function\u00a0C\u00a0and an exception occurs in function\u00a0C. If it is not handled in\u00a0C, the exception passes to\u00a0B\u00a0and then to\u00a0A.\nIf never handled, an error message is spit out and our program come to a sudden, unexpected halt."}, {"count": 112, "topic": "Catching Exceptions in Python", "answer": "In Python, exceptions can be handled using a try statement.\nA critical operation which can raise exception is placed inside the try clause and the code that handles exception is written in except clause.\nIt is up to us, what operations we perform once we have caught the exception. Here is a simple example.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# import module sys to get the type of exception\nimport sys\nrandomList = ['a', 0, 2]\nfor entry in randomList:\n    try:\n        print(\"The entry is\", entry)\n        r = 1/int(entry)\n        break\n    except:\n        print(\"Oops!\",sys.exc_info()[0],\"occured.\")\n        print(\"Next entry.\")\n        print()\nprint(\"The reciprocal of\",entry,\"is\",r)\nRun\n\n\nOutput\nThe entry is a\nOops! <class 'ValueError'> occured.\nNext entry.\n\nThe entry is 0\nOops! <class 'ZeroDivisionError' > occured.\nNext entry.\n\nThe entry is 2\nThe reciprocal of 2 is 0.5\nIn this program, we loop until the user enters an integer that has a valid reciprocal. The portion that can cause exception is placed inside try block.\nIf no exception occurs, except block is skipped and normal flow continues. But if any exception occurs, it is caught by the except block.\nHere, we print the name of the exception using\u00a0ex_info()\u00a0function inside\u00a0sys\u00a0module and ask the user to try again. We can see that the values 'a' and '1.3' causes ValueError and '0' causes ZeroDivisionError."}, {"count": 113, "topic": "Catching Specific Exceptions in Python", "answer": "In the above example, we did not mention any exception in the\u00a0except\u00a0clause.\nThis is not a good programming practice as it will catch all exceptions and handle every case in the same way. We can specify which exceptions an except clause will catch.\nA try clause can have any number of except clause to handle them differently but only one will be executed in case an exception occurs.\nWe can use a tuple of values to specify multiple exceptions in an except clause. Here is an example pseudo code.\ntry:\n   # do something\n   pass\n\nexcept ValueError:\n   # handle ValueError exception\n   pass\n\nexcept (TypeError, ZeroDivisionError):\n   # handle multiple exceptions\n   # TypeError and ZeroDivisionError\n   pass\n\nexcept:\n   # handle all other exceptions\n   pass"}, {"count": 114, "topic": "Raising Exceptions", "answer": "In Python programming, exceptions are raised when corresponding errors occur at run time, but we can forcefully raise it using the keyword raise.\nWe can also optionally pass in value to the exception to clarify why that exception was raised.\n>>> raise KeyboardInterrupt\nTraceback (most recent call last):\n...\nKeyboardInterrupt\n\n>>> raise MemoryError(\"This is an argument\")\nTraceback (most recent call last):\n...\nMemoryError: This is an argument\n\n>>> try:\n...     a = int(input(\"Enter a positive integer: \"))\n...     if a <= 0:\n...         raise ValueError(\"That is not a positive number!\")\n... except ValueError as ve:\n...     print(ve)\n...    \nEnter a positive integer: -2\nThat is not a positive number!"}, {"count": 115, "topic": "try...finally", "answer": "The try statement in Python can have an optional\u00a0finally\u00a0clause. This clause is executed no matter what, and is generally used to release external resources.\nFor example, we may be connected to a remote data center through the network or working with a file or working with a Graphical User Interface (GUI).\nIn all these circumstances, we must clean up the resource once used, whether it was successful or not. These actions (closing a file, GUI or disconnecting from network) are performed in the finally clause to guarantee execution.\nHere is an example of\u00a0\u00a0to illustrate this.\ntry:\n   f = open(\"test.txt\",encoding = 'utf-8')\n   # perform file operations\nfinally:\n   f.close()\nThis type of construct makes sure the file is closed even if an exception occurs."}, {"count": 116, "topic": "Python Custom Exceptions", "answer": "Python has many\u00a0\u00a0which forces your program to output an error when something in it goes wrong.\nHowever, sometimes you may need to create custom exceptions that serves your purpose.\nIn Python, users can define such exceptions by creating a new class. This exception class has to be derived, either directly or indirectly, from\u00a0Exception\u00a0class. Most of the built-in exceptions are also derived form this class.\n>>> class CustomError(Exception):\n...     pass\n...\n\n>>> raise CustomError\nTraceback (most recent call last):\n...\n__main__.CustomError\n\n>>> raise CustomError(\"An error occurred\")\nTraceback (most recent call last):\n...\n__main__.CustomError: An error occurred\nHere, we have created a user-defined exception called\u00a0CustomError\u00a0which is derived from the\u00a0Exception\u00a0class. This new exception can be raised, like other exceptions, using the\u00a0raisestatement with an optional error message.\nWhen we are developing a large Python program, it is a good practice to place all the user-defined exceptions that our program raises in a separate file. Many standard modules do this. They define their exceptions separately as\u00a0exceptions.py\u00a0or\u00a0errors.py\u00a0(generally but not always).\nUser-defined exception class can implement everything a normal class can do, but we generally make them simple and concise. Most implementations declare a custom base class and derive others exception classes from this base class. This concept is made clearer in the following example."}, {"count": 117, "topic": "Example: User-Defined Exception in Python", "answer": "In this example, we will illustrate how user-defined exceptions can be used in a program to raise and catch errors.\nThis program will ask the user to enter a number until they guess a stored number correctly. To help them figure it out, hint is provided whether their guess is greater than or less than the stored number.\n# define Python user-defined exceptions\nclass Error(Exception):\n   \"\"\"Base class for other exceptions\"\"\"\n   pass\n\nclass ValueTooSmallError(Error):\n   \"\"\"Raised when the input value is too small\"\"\"\n   pass\n\nclass ValueTooLargeError(Error):\n   \"\"\"Raised when the input value is too large\"\"\"\n   pass\n\n# our main program\n# user guesses a number until he/she gets it right\n\n# you need to guess this number\nnumber = 10\n\nwhile True:\n   try:\n       i_num = int(input(\"Enter a number: \"))\n       if i_num < number:\n           raise ValueTooSmallError\n       elif i_num > number:\n           raise ValueTooLargeError\n       break\n   except ValueTooSmallError:\n       print(\"This value is too small, try again!\")\n       print()\n   except ValueTooLargeError:\n       print(\"This value is too large, try again!\")\n       print()\n\nprint(\"Congratulations! You guessed it correctly.\")\nHere is a sample run of this program.\nEnter a number: 12\nThis value is too large, try again!\n\nEnter a number: 0\nThis value is too small, try again!\n\nEnter a number: 8\nThis value is too small, try again!\n\nEnter a number: 10\nCongratulations! You guessed it correctly.\nHere, we have defined a base class called\u00a0Error.\nThe other two exceptions (ValueTooSmallError\u00a0and\u00a0ValueTooLargeError) that are actually raised by our program are derived from this class. This is the standard way to define user-defined exceptions in Python programming, but you are not limited to this way only.\n\nPython Object Oriented Programming\nIn this article, you\u2019ll learn about the Object Oriented Programming (OOP) in Python and their fundamental concept with examples."}, {"count": 118, "topic": "Introduction to OOPs in Python", "answer": "Python is a multi-paradigm programming language. Meaning, it supports different programming approach.\nOne of the popular approach to solve a programming problem is by creating objects. This is known as Object-Oriented Programming (OOP).\nAn object has two characteristics:\nattributes\nbehavior\nLet's take an example:\nParrot is an object,\nname, age, color are attributes\nsinging, dancing are behavior\nThe concept of OOP in Python focuses on creating reusable code. This concept is also known as DRY (Don't Repeat Yourself).\nIn Python, the concept of OOP follows some basic principles:"}, {"count": 119, "topic": "Python Classes/Objects", "answer": "Python is an object oriented programming language.\nAlmost everything in Python is an object, with its properties and methods.\nA Class is like an object constructor, or a \"blueprint\" for creating objects."}, {"count": 120, "topic": "Create a Class", "answer": "To create a class, use the keyword\u00a0class:\nExample\nCreate a class named MyClass, with a property named x:\nclass\u00a0MyClass:\n\u00a0 x =\u00a05"}, {"count": 121, "topic": "Create Object", "answer": "Now we can use the class named myClass to create objects:\nExample\nCreate an object named p1, and print the value of x:\np1 = MyClass()\nprint(p1.x)"}, {"count": 122, "topic": "The __init__() Function", "answer": "The examples above are classes and objects in their simplest form, and are not really useful in real life applications.\nTo understand the meaning of classes we have to understand the built-in __init__() function.\nAll classes have a function called __init__(), which is always executed when the class is being initiated.\nUse the __init__() function to assign values to object properties, or other operations that are necessary to do when the object is being created:\nExample\nCreate a class named Person, use the __init__() function to assign values for name and age:\nclass\u00a0Person:\n\u00a0\u00a0def\u00a0__init__(self, name, age):\n\u00a0\u00a0\u00a0\u00a0self.name = name\n\u00a0\u00a0\u00a0 self.age = age\n\np1 = Person(\"John\",\u00a036)\n\nprint(p1.name)\nprint(p1.age)\n\nNote:\u00a0The\u00a0__init__()\u00a0function is called automatically every time the class is being used to create a new object."}, {"count": 123, "topic": "Object Methods", "answer": "Objects can also contain methods. Methods in objects are functions that belong to the object.\nLet us create a method in the Person class:\nExample\nInsert a function that prints a greeting, and execute it on the p1 object:\nclass\u00a0Person:\n\u00a0\u00a0def\u00a0__init__(self, name, age):\n\u00a0\u00a0\u00a0\u00a0self.name = name\n\u00a0\u00a0\u00a0 self.age = age\n\n\u00a0\u00a0def\u00a0myfunc(self):\n\u00a0\u00a0\u00a0\u00a0print(\"Hello my name is \"\u00a0+ self.name)\n\np1 = Person(\"John\",\u00a036)\np1.myfunc()\n\nNote:\u00a0The\u00a0self\u00a0parameter is a reference to the current instance of the class, and is used to access variables that belong to the class."}, {"count": 124, "topic": "The self Parameter", "answer": "The\u00a0self\u00a0parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class.\nIt does not have to be named\u00a0self\u00a0, you can call it whatever you like, but it has to be the first parameter of any function in the class:\nExample\nUse the words\u00a0mysillyobject\u00a0and\u00a0abc\u00a0instead of\u00a0self:\nclass\u00a0Person:\n\u00a0\u00a0def\u00a0__init__(mysillyobject, name, age):\n\u00a0\u00a0\u00a0\u00a0mysillyobject.name = name\n\u00a0\u00a0\u00a0 mysillyobject.age = age\n\n\u00a0\u00a0def\u00a0myfunc(abc):\n\u00a0\u00a0\u00a0\u00a0print(\"Hello my name is \"\u00a0+ abc.name)\n\np1 = Person(\"John\",\u00a036)\np1.myfunc()"}, {"count": 125, "topic": "Modify Object Properties", "answer": "You can modify properties on objects like this:\nExample\nSet the age of p1 to 40:\np1.age =\u00a040"}, {"count": 126, "topic": "Delete Object Properties", "answer": "You can delete properties on objects by using the\u00a0del\u00a0keyword:\nExample\nDelete the age property from the p1 object:\ndel\u00a0p1.age"}, {"count": 127, "topic": "Delete Objects", "answer": "You can delete objects by using the\u00a0del\u00a0keyword:\nExample\nDelete the p1 object:\ndel\u00a0p1"}, {"count": 128, "topic": "Inheritance", "answer": "Inheritance is a way of creating new class for using details of existing class without modifying it. The newly formed class is a derived class (or child class). Similarly, the existing class is a base class (or parent class).\nExample 3: Use of Inheritance in Python\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# parent class\nclass Bird:\n    \n    def __init__(self):\n        print(\"Bird is ready\")\n    def whoisThis(self):\n        print(\"Bird\")\n    def swim(self):\n        print(\"Swim faster\")\n# child class\nclass Penguin(Bird):\n    def __init__(self):\n        # call super() function\n        super().__init__()\n        print(\"Penguin is ready\")\n    def whoisThis(self):\n        print(\"Penguin\")\n    def run(self):\n        print(\"Run faster\")\npeggy = Penguin()\npeggy.whoisThis()\npeggy.swim()\npeggy.run()\nRun\n\n\nWhen we run this program, the output will be:\nBird is ready\nPenguin is ready\nPenguin\nSwim faster\nRun faster\nIn the above program, we created two classes i.e.\u00a0Bird\u00a0(parent class) and\u00a0Penguin\u00a0(child class). The child class inherits the functions of parent class. We can see this from\u00a0swim()method. Again, the child class modified the behavior of parent class. We can see this from whoisThis() method. Furthermore, we extend the functions of parent class, by creating a new\u00a0run()\u00a0method.\nAdditionally, we use\u00a0super()\u00a0function before\u00a0__init__()\u00a0method. This is because we want to pull the content of\u00a0__init__()\u00a0method from the parent class into the child class."}, {"count": 129, "topic": "Encapsulation", "answer": "Using OOP in Python, we can restrict access to methods and variables. This prevent data from direct modification which is called encapsulation. In Python, we denote private attribute using underscore as prefix i.e single \u201c _ \u201c or double \u201c __\u201c."}, {"count": 130, "topic": "Example 4: Data Encapsulation in Python", "answer": "\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Computer:\n    def __init__(self):\n        self.__maxprice = 900\n    def sell(self):\n        print(\"Selling Price: {}\".format(self.__maxprice))\n    def setMaxPrice(self, price):\n        self.__maxprice = price\nc = Computer()\nc.sell()\n# change the price\nc.__maxprice = 1000\nc.sell()\n# using setter function\nc.setMaxPrice(1000)\nc.sell()\nRun\n\n\nWhen we run this program, the output will be:\nSelling Price: 900\nSelling Price: 900\nSelling Price: 1000\nIn the above program, we defined a class\u00a0Computer. We use\u00a0__init__()\u00a0method to store the maximum selling price of computer. We tried to modify the price. However, we can\u2019t change it because Python treats the\u00a0__maxprice\u00a0as private attributes. To change the value, we used a setter function i.e\u00a0setMaxPrice()\u00a0which takes price as parameter."}, {"count": 131, "topic": "Polymorphism", "answer": "Polymorphism is an ability (in OOP) to use common interface for multiple form (data types).\nSuppose, we need to color a shape, there are multiple shape option (rectangle, square, circle). However we could use same method to color any shape. This concept is called Polymorphism."}, {"count": 132, "topic": "Example 5: Using Polymorphism in Python", "answer": "\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nclass Parrot:\n    def fly(self):\n        print(\"Parrot can fly\")\n    \n    def swim(self):\n        print(\"Parrot can't swim\")\nclass Penguin:\n    def fly(self):\n        print(\"Penguin can't fly\")\n    \n    def swim(self):\n        print(\"Penguin can swim\")\n# common interface\ndef flying_test(bird):\n    bird.fly()\n#instantiate objects\nblu = Parrot()\npeggy = Penguin()\n# passing the object\nflying_test(blu)\nflying_test(peggy)\nRun\n\n\nWhen we run above program, the output will be:\nParrot can fly\nPenguin can't fly\nIn the above program, we defined two classes\u00a0Parrot\u00a0and\u00a0Penguin. Each of them have common method\u00a0fly()\u00a0method. However, their functions are different. To allow polymorphism, we created common interface i.e\u00a0flying_test()\u00a0function that can take any object. Then, we passed the objects\u00a0blu\u00a0and\u00a0peggy\u00a0in the\u00a0flying_test()\u00a0function, it ran effectively."}, {"count": 133, "topic": "Key Points\u00a0to Remember:", "answer": "The programming gets easy and efficient.\nThe class is sharable, so codes can be reused.\nThe productivity of programmars increases\nData is safe and secure with data abstraction."}, {"count": 134, "topic": "What is operator overloading in Python?", "answer": "\u00a0work for built-in classes. But same operator behaves differently with different types. For example, the\u00a0+\u00a0operator will, perform arithmetic addition on two numbers, merge two lists and concatenate two strings.\nThis feature in Python, that allows same operator to have different meaning according to the context is called operator overloading.\nSo what happens when we use them with objects of a user-defined class? Let us consider the following class, which tries to simulate a point in 2-D coordinate system.\n\n\n\n\n1\n2\n3\n4\nclass Point:\n    def __init__(self, x = 0, y = 0):\n        self.x = x\n        self.y = y\nRun\n\n\nNow, run the code and try to add two points in Python shell.\n\n>>> p1 = Point(2,3)\n>>> p2 = Point(-1,2)\n>>> p1 + p2\nTraceback (most recent call last):\n...\nTypeError: unsupported operand type(s) for +: 'Point' and 'Point'\nWhoa! That's a lot of complains.\u00a0TypeError\u00a0was raised since Python didn't know how to add two\u00a0Point\u00a0objects together.\nHowever, the good news is that we can teach this to Python through operator overloading. But first, let's get a notion about special functions."}, {"count": 135, "topic": "Python Iterators", "answer": "An iterator is an object that contains a countable number of values.\nAn iterator is an object that can be iterated upon, meaning that you can traverse through all the values.\nTechnically, in Python, an iterator is an object which implements the iterator protocol, which consist of the methods\u00a0__iter__()\u00a0and\u00a0__next__()."}, {"count": 136, "topic": "Iterator vs Iterable", "answer": "Lists, tuples, dictionaries, and sets are all iterable objects. They are iterable\u00a0containers\u00a0which you can get an iterator from.\nAll these objects have a\u00a0iter()\u00a0method which is used to get an iterator:\nExample\nReturn an iterator from a tuple, and print each value:\nmytuple = (\"apple\",\u00a0\"banana\",\u00a0\"cherry\")\nmyit =\u00a0iter(mytuple)\n\nprint(next(myit))\nprint(next(myit))\nprint(next(myit))\n\n\nEven strings are iterable objects, and can return an iterator:\nExample\nStrings are also iterable objects, containing a sequence of characters:\nmystr =\u00a0\"banana\"\nmyit =\u00a0iter(mystr)\n\nprint(next(myit))\nprint(next(myit))\nprint(next(myit))\nprint(next(myit))\nprint(next(myit))\nprint(next(myit))"}, {"count": 137, "topic": "Looping Through an Iterator", "answer": "We can also use a\u00a0for\u00a0loop to iterate through an iterable object:\nExample\nIterate the values of a tuple:\nmytuple = (\"apple\",\u00a0\"banana\",\u00a0\"cherry\")\n\nfor\u00a0x\u00a0in\u00a0mytuple:\n\u00a0\u00a0print(x)\n\nExample\nIterate the characters of a string:\nmystr =\u00a0\"banana\"\n\nfor\u00a0x\u00a0in\u00a0mystr:\n\u00a0\u00a0print(x)\n\nThe\u00a0for\u00a0loop actually creates an iterator object and executes the next() method for each loop."}, {"count": 138, "topic": "Create an Iterator", "answer": "To create an object/class as an iterator you have to implement the methods\u00a0__iter__()\u00a0and\u00a0__next__()\u00a0to your object.\nAs you have learned in the\u00a0\u00a0chapter, all classes have a function called\u00a0__init__(), which allows you do some initializing when the object is being created.\nThe\u00a0__iter__()\u00a0method acts similar, you can do operations (initializing etc.), but must always return the iterator object itself.\nThe\u00a0__next__()\u00a0method also allows you to do operations, and must return the next item in the sequence.\nExample\nCreate an iterator that returns numbers, starting with 1, and each sequence will increase by one (returning 1,2,3,4,5 etc.):\nclass\u00a0MyNumbers:\n\u00a0\u00a0def\u00a0__iter__(self):\n\u00a0\u00a0\u00a0 self.a =\u00a01\n\u00a0\u00a0\u00a0\u00a0return\u00a0self\n\n\u00a0\u00a0def\u00a0__next__(self):\n\u00a0\u00a0\u00a0\u00a0x = self.a\n\u00a0\u00a0\u00a0 self.a +=\u00a01\n\u00a0\u00a0\u00a0\u00a0return\u00a0x\n\nmyclass = MyNumbers()\nmyiter = iter(myclass)\n\nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))"}, {"count": 139, "topic": "StopIteration", "answer": "The example above would continue forever if you had enough next() statements, or if it was used in a\u00a0for\u00a0loop.\nTo prevent the iteration to go on forever, we can use the\u00a0StopIteration\u00a0statement.\nIn the\u00a0__next__()\u00a0method, we can add a terminating condition to raise an error if the iteration is done a specified number of times:\nExample\nStop after 20 iterations:\nclass\u00a0MyNumbers:\n\u00a0\u00a0def\u00a0__iter__(self):\n\u00a0\u00a0\u00a0 self.a =\u00a01\n\u00a0\u00a0\u00a0\u00a0return\u00a0self\n\n\u00a0\u00a0def\u00a0__next__(self):\n\u00a0\u00a0\u00a0\u00a0if\u00a0self.a <=\u00a020:\n\u00a0\u00a0\u00a0\u00a0\u00a0 x = self.a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.a +=\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0x\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0raise\u00a0StopIteration\n\nmyclass =\u00a0MyNumbers()\nmyiter = iter(myclass)\n\nfor\u00a0x\u00a0in\u00a0myiter:\n\u00a0\u00a0print(x)"}, {"count": 140, "topic": "What is a Module?", "answer": "Consider a module to be the same as a code library.\nA file containing a set of functions you want to include in your application."}, {"count": 141, "topic": "Create a Module", "answer": "To create a module just save the code you want in a file with the file extension\u00a0.py:\nExample\nSave this code in a file named\u00a0mymodule.py\ndef\u00a0greeting(name):\n\u00a0\u00a0print(\"Hello, \"\u00a0+ name)"}, {"count": 142, "topic": "Use a Module", "answer": "Now we can use the module we just created, by using the\u00a0import\u00a0statement:\nExample\nImport the module named mymodule, and call the greeting function:\nimport\u00a0mymodule\n\nmymodule.greeting(\"Jonathan\")\n\nNote:\u00a0When using a function from a module, use the syntax:\u00a0module_name.function_name."}, {"count": 143, "topic": "Variables in Module", "answer": "The module can contain functions, as already described, but also variables of all types (arrays, dictionaries, objects etc):\nExample\nSave this code in the file\u00a0mymodule.py\nperson1 = {\n\u00a0\u00a0\"name\":\u00a0\"John\",\n\u00a0\u00a0\"age\":\u00a036,\n\u00a0\u00a0\"country\":\u00a0\"Norway\"\n}\nExample\nImport the module named mymodule, and access the person1 dictionary:\nimport\u00a0mymodule\n\na = mymodule.person1[\"age\"]\nprint(a)"}, {"count": 144, "topic": "Naming a Module", "answer": "You can name the module file whatever you like, but it must have the file extension\u00a0.py"}, {"count": 145, "topic": "Re-naming a Module", "answer": "You can create an alias when you import a module, by using the\u00a0as\u00a0keyword:\nExample\nCreate an alias for\u00a0mymodule\u00a0called\u00a0mx:\nimport\u00a0mymodule\u00a0as\u00a0mx\n\na = mx.person1[\"age\"]\nprint(a)"}, {"count": 146, "topic": "Built-in Modules", "answer": "There are several built-in modules in Python, which you can import whenever you like.\nExample\nImport and use the\u00a0platform\u00a0module:\nimport\u00a0platform\n\nx = platform.system()\nprint(x)"}, {"count": 147, "topic": "Using the dir() Function", "answer": "There is a built-in function to list all the function names (or variable names) in a module. The\u00a0dir()\u00a0function:\nExample\nList all the defined names belonging to the platform module:\nimport\u00a0platform\n\nx =\u00a0dir(platform)\nprint(x)\n\nNote:\u00a0The dir() function can be used on\u00a0all\u00a0modules, also the ones you create yourself."}, {"count": 148, "topic": "Import From Module", "answer": "You can choose to import only parts from a module, by using the\u00a0from\u00a0keyword.\nExample\nThe module named\u00a0mymodule\u00a0has one function and one dictionary:\ndef\u00a0greeting(name):\n\u00a0\u00a0print(\"Hello, \"\u00a0+ name)\n\nperson1\u00a0= {\n\u00a0\u00a0\"name\":\u00a0\"John\",\n\u00a0\u00a0\"age\":\u00a036,\n\u00a0\u00a0\"country\":\u00a0\"Norway\"\n}\n\nExample\nImport only the person1 dictionary from the module:\nfrom\u00a0mymodule\u00a0import\u00a0person1\n\nprint\u00a0(person1[\"age\"])\n\n\nNote:\u00a0When importing using the\u00a0from\u00a0keyword, do not use the module name when referring to elements in the module. Example:\u00a0person1[\"age\"],\u00a0not\u00a0mymodule.person1[\"age\"]"}, {"count": 149, "topic": "Python Dates", "answer": "A date in Python is not a data type of its own, but we can import a module named\u00a0datetime\u00a0to work with dates as date objects.\nExample\nImport the datetime module and display the current date:\nimport\u00a0datetime\n\nx = datetime.datetime.now()\nprint(x)"}, {"count": 150, "topic": "Date Output", "answer": "When we execute the code from the example above the result will be:\n2019-09-01 12:21:07.786423\nThe date contains year, month, day, hour, minute, second, and microsecond.\nThe\u00a0datetime\u00a0module has many methods to return information about the date object.\nHere are a few examples, you will learn more about them later in this chapter:\nExample\nReturn the year and name of weekday:\nimport\u00a0datetime\n\nx = datetime.datetime.now()\n\nprint(x.year)\nprint(x.strftime(\"%A\"))"}, {"count": 151, "topic": "Creating Date Objects", "answer": "To create a date, we can use the\u00a0datetime()\u00a0class (constructor) of the\u00a0datetime\u00a0module.\nThe\u00a0datetime()\u00a0class requires three parameters to create a date: year, month, day.\nExample\nCreate a date object:\nimport\u00a0datetime\n\nx = datetime.datetime(2020,\u00a05,\u00a017)\n\nprint(x)\n\nThe\u00a0datetime()\u00a0class also takes parameters for time and timezone (hour, minute, second, microsecond, tzone), but they are optional, and has a default value of\u00a00, (None\u00a0for timezone)."}, {"count": 152, "topic": "The strftime() Method", "answer": "The\u00a0datetime\u00a0object has a method for formatting date objects into readable strings.\nThe method is called\u00a0strftime(), and takes one parameter,\u00a0format, to specify the format of the returned string:\nExample\nDisplay the name of the month:\nimport\u00a0datetime\n\nx = datetime.datetime(2018,\u00a06,\u00a01)\n\nprint(x.strftime(\"%B\"))"}, {"count": 153, "topic": "Python\u00a0JSON", "answer": "\nJSON is a syntax for storing and exchanging data.\nJSON is text, written with JavaScript object notation."}, {"count": 154, "topic": "JSON in Python", "answer": "Python has a built-in package called\u00a0json, which can be used to work with JSON data.\nExample\nImport the json module:\nimport\u00a0json"}, {"count": 155, "topic": "Parse JSON - Convert from JSON to Python", "answer": "If you have a JSON string, you can parse it by using the\u00a0json.loads()\u00a0method.\nThe result will be a\u00a0.\nExample\nConvert from JSON to Python:\nimport\u00a0json\n\n# some JSON:\nx =\u00a0\u00a0'{ \"name\":\"John\", \"age\":30, \"city\":\"New York\"}'\n\n# parse x:\ny = json.loads(x)\n\n# the result is a Python dictionary:\nprint(y[\"age\"])"}, {"count": 156, "topic": "Convert from Python to JSON", "answer": "If you have a Python object, you can convert it into a JSON string by using the\u00a0json.dumps()\u00a0method.\nExample\nConvert from Python to JSON:\nimport\u00a0json\n\n# a Python object (dict):\nx = {\n\u00a0\u00a0\"name\":\u00a0\"John\",\n\u00a0\u00a0\"age\":\u00a030,\n\u00a0\u00a0\"city\":\u00a0\"New York\"\n}\n\n# convert into JSON:\ny = json.dumps(x)\n\n# the result is a JSON string:\nprint(y)\n\n\n\nYou can convert Python objects of the following types, into JSON strings:\ndict\nlist\ntuple\nstring\nint\nfloat\nTrue\nFalse\nNone\nExample\nConvert Python objects into JSON strings, and print the values:\nimport\u00a0json\n\nprint(json.dumps({\"name\":\u00a0\"John\",\u00a0\"age\":\u00a030}))\nprint(json.dumps([\"apple\",\u00a0\"bananas\"]))\nprint(json.dumps((\"apple\",\u00a0\"bananas\")))\nprint(json.dumps(\"hello\"))\nprint(json.dumps(42))\nprint(json.dumps(31.76))\nprint(json.dumps(True))\nprint(json.dumps(False))\nprint(json.dumps(None))\n\n\nWhen you convert from Python to JSON, Python objects are converted into the JSON (JavaScript) equivalent:"}, {"count": 157, "topic": "What is PIP?", "answer": "PIP is a package manager for Python packages, or modules if you like.\nNote:\u00a0If you have Python version 3.4 or later, PIP is included by default."}, {"count": 158, "topic": "What is a Package?", "answer": "A package contains all the files you need for a module.\nModules are Python code libraries you can include in your project."}, {"count": 159, "topic": "Check if PIP is Installed", "answer": "Navigate your command line to the location of Python's script directory, and type the following:\nExample\nCheck PIP version:\nC:\\Users\\Your Name\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts>pip --version"}, {"count": 160, "topic": "Install PIP", "answer": "If you do not have PIP installed, you can download and install it from this page:\u00a0"}, {"count": 161, "topic": "Download a Package", "answer": "Downloading a package is very easy.\nOpen the command line interface and tell PIP to download the package you want.\nNavigate your command line to the location of Python's script directory, and type the following:\nExample\nDownload a package named \"camelcase\":\nC:\\Users\\Your Name\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts>pip install camelcase"}, {"count": 162, "topic": "What are generators in Python?", "answer": "There is a lot of overhead in building an\u00a0; we have to implement a class with\u00a0__iter__()\u00a0and\u00a0__next__()\u00a0method, keep track of internal states, raise\u00a0StopIterationwhen there was no values to be returned etc.\nThis is both lengthy and counter intuitive. Generator comes into rescue in such situations.\nPython generators are a simple way of creating iterators. All the overhead we mentioned above are automatically handled by generators in Python.\nSimply speaking, a generator is a function that returns an object (iterator) which we can iterate over (one value at a time)."}, {"count": 163, "topic": "How to create a generator in Python?", "answer": "It is fairly simple to create a generator in Python. It is as easy as defining a normal function with\u00a0yield\u00a0statement instead of a\u00a0return\u00a0statement.\nIf a function contains at least one\u00a0yield\u00a0statement (it may contain other\u00a0yield\u00a0or\u00a0returnstatements), it becomes a generator function. Both\u00a0yield\u00a0and\u00a0return\u00a0will return some value from a function.\nThe difference is that, while a\u00a0return\u00a0statement terminates a function entirely,\u00a0yieldstatement pauses the function saving all its states and later continues from there on successive calls."}, {"count": 164, "topic": "Differences between Generator function and a Normal function", "answer": "Here is how a generator function differs from a\u00a0.\nGenerator function contains one or more\u00a0yield\u00a0statement.\nWhen called, it returns an object (iterator) but does not start execution immediately.\nMethods like\u00a0__iter__()\u00a0and\u00a0__next__()\u00a0are implemented automatically. So we can iterate through the items using\u00a0next().\nOnce the function yields, the function is paused and the control is transferred to the caller.\nLocal variables and their states are remembered between successive calls.\nFinally, when the function terminates,\u00a0StopIteration\u00a0is raised automatically on further calls.\nHere is an example to illustrate all of the points stated above. We have a generator function named\u00a0my_gen()\u00a0with several\u00a0yield\u00a0statements.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# A simple generator function\ndef my_gen():\n    n = 1\n    print('This is printed first')\n    # Generator function contains yield statements\n    yield n\n    n += 1\n    print('This is printed second')\n    yield n\n    n += 1\n    print('This is printed at last')\n    yield n\nRun\n\n\nAn interactive run in the interpreter is given below. Run these in the Python shell to see the output.\n>>> # It returns an object but does not start execution immediately.\n>>> a = my_gen()\n\n>>> # We can iterate through the items using next().\n>>> next(a)\nThis is printed first\n1\n>>> # Once the function yields, the function is paused and the control is transferred to the caller.\n\n>>> # Local variables and theirs states are remembered between successive calls.\n>>> next(a)\nThis is printed second\n2\n\n>>> next(a)\nThis is printed at last\n3\n\n>>> # Finally, when the function terminates, StopIteration is raised automatically on further calls.\n>>> next(a)\nTraceback (most recent call last):\n...\nStopIteration\n>>> next(a)\nTraceback (most recent call last):\n...\nStopIteration\nOne interesting thing to note in the above example is that, the value of variable\u00a0n\u00a0is remembered between each call.\nUnlike normal functions, the local variables are not destroyed when the function yields. Furthermore, the generator object can be iterated only once.\nTo restart the process we need to create another generator object using something like\u00a0a = my_gen().\nNote:\u00a0One final thing to note is that we can use generators with\u00a0\u00a0directly.\nThis is because, a\u00a0for\u00a0loop takes an iterator and iterates over it using\u00a0next()\u00a0function. It automatically ends when\u00a0StopIteration\u00a0is raised. Check here to\u00a0.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# A simple generator function\ndef my_gen():\n    n = 1\n    print('This is printed first')\n    # Generator function contains yield statements\n    yield n\n    n += 1\n    print('This is printed second')\n    yield n\n    n += 1\n    print('This is printed at last')\n    yield n\n# Using for loop\nfor item in my_gen():\n    print(item)    \nRun\n\nWhen you run the program, the output will be:\nThis is printed first\n1\nThis is printed second\n2\nThis is printed at last\n3"}, {"count": 165, "topic": "Python Generators with a Loop", "answer": "The above example is of less use and we studied it just to get an idea of what was happening in the background.\nNormally, generator functions are implemented with a loop having a suitable terminating condition.\nLet's take an example of a generator that reverses a string.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\ndef rev_str(my_str):\n    length = len(my_str)\n    for i in range(length - 1,-1,-1):\n        yield my_str[i]\n# For loop to reverse the string\n# Output:\n# o\n# l\n# l\n# e\n# h\nfor char in rev_str(\"hello\"):\n     print(char)\nRun\n\nIn this example, we use\u00a0range()\u00a0function to get the index in reverse order using the for loop.\nIt turns out that this generator function not only works with string, but also with other kind of iterables like\u00a0,\u00a0\u00a0etc."}, {"count": 166, "topic": "Python Generator Expression", "answer": "Simple generators can be easily created on the fly using generator expressions. It makes building generators easy.\nSame as lambda function creates an\u00a0, generator expression creates an anonymous generator function.\nThe syntax for generator expression is similar to that of a\u00a0. But the square brackets are replaced with round parentheses.\nThe major difference between a list comprehension and a generator expression is that while list comprehension produces the entire list, generator expression produces one item at a time.\nThey are kind of lazy, producing items only when asked for. For this reason, a generator expression is much more memory efficient than an equivalent list comprehension.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# Initialize the list\nmy_list = [1, 3, 6, 10]\n# square each term using list comprehension\n# Output: [1, 9, 36, 100]\n[x**2 for x in my_list]\n# same thing can be done using generator expression\n# Output: <generator object <genexpr> at 0x0000000002EBDAF8>\n(x**2 for x in my_list)\nRun\n\n\nWe can see above that the generator expression did not produce the required result immediately. Instead, it returned a generator object with produces items on demand.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# Intialize the list\nmy_list = [1, 3, 6, 10]\na = (x**2 for x in my_list)\n# Output: 1\nprint(next(a))\n# Output: 9\nprint(next(a))\n# Output: 36\nprint(next(a))\n# Output: 100\nprint(next(a))\n# Output: StopIteration\nnext(a)\nRun\n\n\nGenerator expression can be used inside functions. When used in such a way, the round parentheses can be dropped.\n>>> sum(x**2 for x in my_list)\n146\n\n>>> max(x**2 for x in my_list)\n100"}, {"count": 167, "topic": "Why generators are used in Python?", "answer": "There are several reasons which make generators an attractive implementation to go for.\n1. Easy to Implement\nGenerators can be implemented in a clear and concise way as compared to their iterator class counterpart. Following is an example to implement a sequence of power of 2's using iterator class.\nclass PowTwo:\n    def __init__(self, max = 0):\n        self.max = max\n\n    def __iter__(self):\n        self.n = 0\n        return self\n\n    def __next__(self):\n        if self.n > self.max:\n            raise StopIteration\n\n        result = 2 ** self.n\n        self.n += 1\n        return result\nThis was lengthy. Now lets do the same using a generator function.\ndef PowTwoGen(max = 0):\n    n = 0\n    while n < max:\n        yield 2 ** n\n        n += 1\nSince, generators keep track of details automatically, it was concise and much cleaner in implementation.\n2. Memory Efficient\nA normal function to return a sequence will create the entire sequence in memory before returning the result. This is an overkill if the number of items in the sequence is very large.\nGenerator implementation of such sequence is memory friendly and is preferred since it only produces one item at a time.\n3. Represent Infinite Stream\nGenerators are excellent medium to represent an infinite stream of data. Infinite streams cannot be stored in memory and since generators produce only one item at a time, it can represent infinite stream of data.\nThe following example can generate all the even numbers (at least in theory).\ndef all_even():\n    n = 0\n    while True:\n        yield n\n        n += 2\n4. Pipelining Generators\nGenerators can be used to pipeline a series of operations. This is best illustrated using an example.\nSuppose we have a log file from a famous fast food chain. The log file has a column (4th column) that keeps track of the number of pizza sold every hour and we want to sum it to find the total pizzas sold in 5 years.\nAssume everything is in string and numbers that are not available are marked as 'N/A'. A generator implementation of this could be as follows.\nwith open('sells.log') as file:\n    pizza_col = (line[3] for line in file)\n    per_hour = (int(x) for x in pizza_col if x != 'N/A')\n    print(\"Total pizzas sold = \",sum(per_hour))\nThis pipelining is efficient and easy to read (and yes, a lot cooler!)."}, {"count": 168, "topic": "What are decorators in Python?", "answer": "Python has an interesting feature called\u00a0decorators\u00a0to add functionality to an existing code.\nThis is also called\u00a0metaprogramming\u00a0as a part of the program tries to modify another part of the program at compile time."}, {"count": 169, "topic": "Prerequisites for learning decorators", "answer": "In order to understand about decorators, we must first know a few basic things in Python.\nWe must be comfortable with the fact that, everything in Python (Yes! Even classes), are\u00a0. Names that we define are simply identifiers bound to these objects.\u00a0\u00a0are no exceptions, they are objects too (with attributes). Various different names can be bound to the same function object.\nHere is an example.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\ndef first(msg):\n    print(msg)    \nfirst(\"Hello\")\nsecond = first\nsecond(\"Hello\")\nRun\n\n\nWhen you run the code, both functions\u00a0first\u00a0and\u00a0second\u00a0gives same output. Here, the names\u00a0first\u00a0and\u00a0second\u00a0refer to the same function object.\nNow things start getting weirder.\nFunctions can be passed as arguments to another function.\nIf you have used functions like\u00a0map,\u00a0filter\u00a0and\u00a0reduce\u00a0in Python, then you already know about this.\nSuch function that take other functions as arguments are also called\u00a0higher order functions. Here is an example of such a function.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\ndef inc(x):\n    return x + 1\ndef dec(x):\n    return x - 1\ndef operate(func, x):\n    result = func(x)\n    return result\nRun\n\n\nWe invoke the function as follows.\n>>> operate(inc,3)\n4\n>>> operate(dec,3)\n2\nFurthermore, a function can return another function.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\ndef is_called():\n    def is_returned():\n        print(\"Hello\")\n    return is_returned\nnew = is_called()\n#Outputs \"Hello\"\nnew()\nRun\n\n\nHere,\u00a0is_returned()\u00a0is a nested function which is defined and returned, each time we call\u00a0is_called().\nFinally, we must know about\u00a0."}, {"count": 170, "topic": "Getting back to Decorators", "answer": "Functions and methods are called\u00a0callable\u00a0as they can be called.\nIn fact, any object which implements the special method\u00a0__call__()\u00a0is termed callable. So, in the most basic sense, a decorator is a callable that returns a callable.\nBasically, a decorator takes in a function, adds some functionality and returns it.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\ndef make_pretty(func):\n    def inner():\n        print(\"I got decorated\")\n        func()\n    return inner\ndef ordinary():\n    print(\"I am ordinary\")\nRun\n\n\nWhen you run the following codes in shell,\n>>> ordinary()\nI am ordinary\n\n>>> # let's decorate this ordinary function\n>>> pretty = make_pretty(ordinary)\n>>> pretty()\nI got decorated\nI am ordinary\nIn the example shown above,\u00a0make_pretty()\u00a0is a decorator. In the assignment step.\npretty = make_pretty(ordinary)\nThe function\u00a0ordinary()\u00a0got decorated and the returned function was given the name\u00a0pretty.\nWe can see that the decorator function added some new functionality to the original function. This is similar to packing a gift. The decorator acts as a wrapper. The nature of the object that got decorated (actual gift inside) does not alter. But now, it looks pretty (since it got decorated).\nGenerally, we decorate a function and reassign it as,\nordinary = make_pretty(ordinary).\nThis is a common construct and for this reason, Python has a syntax to simplify this.\nWe can use the\u00a0@\u00a0symbol along with the name of the decorator function and place it above the definition of the function to be decorated. For example,\n@make_pretty\ndef ordinary():\n    print(\"I am ordinary\")\nis equivalent to\ndef ordinary():\n    print(\"I am ordinary\")\nordinary = make_pretty(ordinary)\nThis is just a syntactic sugar to implement decorators."}, {"count": 171, "topic": "Decorating Functions with Parameters", "answer": "The above decorator was simple and it only worked with functions that did not have any parameters. What if we had functions that took in parameters like below?\ndef divide(a, b):\n    return a/b\nThis function has two parameters,\u00a0a\u00a0and\u00a0b. We know, it will give error if we pass in\u00a0b\u00a0as 0.\n>>> divide(2,5)\n0.4\n>>> divide(2,0)\nTraceback (most recent call last):\n...\nZeroDivisionError: division by zero\nNow let's make a decorator to check for this case that will cause the error.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\ndef smart_divide(func):\n   def inner(a,b):\n      print(\"I am going to divide\",a,\"and\",b)\n      if b == 0:\n         print(\"Whoops! cannot divide\")\n         return\n      return func(a,b)\n   return inner\n@smart_divide\ndef divide(a,b):\n    return a/b\nRun\n\n\nThis new implementation will return\u00a0None\u00a0if the error condition arises.\n>>> divide(2,5)\nI am going to divide 2 and 5\n0.4\n\n>>> divide(2,0)\nI am going to divide 2 and 0\nWhoops! cannot divide\nIn this manner we can decorate functions that take parameters.\nA keen observer will notice that parameters of the nested\u00a0inner()\u00a0function inside the decorator is same as the parameters of functions it decorates. Taking this into account, now we can make general decorators that work with any number of parameter.\nIn Python, this magic is done as\u00a0function(*args, **kwargs). In this way,\u00a0args\u00a0will be the\u00a0\u00a0of positional arguments and\u00a0kwargs\u00a0will be the\u00a0\u00a0of keyword arguments. An example of such decorator will be.\ndef works_for_all(func):\n    def inner(*args, **kwargs):\n        print(\"I can decorate any function\")\n        return func(*args, **kwargs)\n    return inner"}, {"count": 172, "topic": "Chaining Decorators in Python", "answer": "Multiple decorators can be chained in Python.\nThis is to say, a function can be decorated multiple times with different (or same) decorators. We simply place the decorators above the desired function.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ndef star(func):\n    def inner(*args, **kwargs):\n        print(\"*\" * 30)\n        func(*args, **kwargs)\n        print(\"*\" * 30)\n    return inner\ndef percent(func):\n    def inner(*args, **kwargs):\n        print(\"%\" * 30)\n        func(*args, **kwargs)\n        print(\"%\" * 30)\n    return inner\n@star\n@percent\ndef printer(msg):\n    print(msg)\nprinter(\"Hello\")\nRun\n\n\nThis will give the output.\n\n******************************\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nHello\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n******************************\nThe above syntax of,\n@star\n@percent\ndef printer(msg):\n    print(msg)\nis equivalent to\ndef printer(msg):\n    print(msg)\nprinter = star(percent(printer))\nThe order in which we chain decorators matter. If we had reversed the order as,\n@percent\n@star\ndef printer(msg):\n    print(msg)\nThe execution would take place as,\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n******************************\nHello\n******************************\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"}]}